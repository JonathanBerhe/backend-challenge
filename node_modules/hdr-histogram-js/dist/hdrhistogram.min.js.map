{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///hdrhistogram.min.js","webpack:///webpack/bootstrap a8fef650f1e23151832d","webpack:///./src/AbstractHistogram.ts","webpack:///./src/AbstractHistogramBase.ts","webpack:///./src/ByteBuffer.ts","webpack:///./src/Int32Histogram.ts","webpack:///./src/encoding.ts","webpack:///./src/AbstractHistogramIterator.ts","webpack:///./src/formatters.ts","webpack:///external \"pako\"","webpack:///./~/base64-js/index.js","webpack:///./src/AbstractHistogram.encoding.ts","webpack:///./src/EncodableHistogram.ts","webpack:///./src/Float64Histogram.ts","webpack:///./src/HistogramIterationValue.ts","webpack:///./src/HistogramLogReader.ts","webpack:///./src/HistogramLogWriter.ts","webpack:///./src/Int16Histogram.ts","webpack:///./src/Int8Histogram.ts","webpack:///./src/PercentileIterator.ts","webpack:///./src/RecordedValuesIterator.ts","webpack:///./src/Recorder.ts","webpack:///./src/ZigZagEncoding.ts","webpack:///./src/index.ts","webpack:///./src/ulp.ts"],"names":["root","factory","exports","module","require","define","amd","hdr","pako","this","__WEBPACK_EXTERNAL_MODULE_8__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__extends","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","hasOwnProperty","__","constructor","prototype","create","defineProperty","value","AbstractHistogramBase_1","RecordedValuesIterator_1","PercentileIterator_1","formatters_1","ulp_1","pow","Math","floor","ceil","log2","max","min","AbstractHistogram","_super","lowestDiscernibleValue","highestTrackableValue","numberOfSignificantValueDigits","_this","maxValue","minNonZeroValue","Number","MAX_SAFE_INTEGER","Error","identity","AbstractHistogramBase","identityBuilder","init","updatedMaxValue","internalValue","unitMagnitudeMask","updateMinNonZeroValue","lowestDiscernibleValueRounded","resetMinNonZeroValue","integerToDoubleValueConversionRatio","normalizingIndexOffset","setNormalizingIndexOffset","largestValueWithSingleUnitResolution","unitMagnitude","subBucketCountMagnitude","subBucketHalfCountMagnitude","subBucketCount","subBucketHalfCount","subBucketMask","establishSize","leadingZeroCountBase","percentileIterator","default","recordedValuesIterator","newHighestTrackableValue","countsArrayLength","determineArrayLengthNeeded","bucketCount","getBucketsNeededToCoverValue","getLengthForNumberOfBuckets","numberOfBuckets","lengthNeeded","smallestUntrackableValue","bucketsNeeded","recordValue","recordSingleValue","countsIndex","countsArrayIndex","handleRecordException","incrementCountAtIndex","updateMinAndMax","incrementTotalCount","count","autoResize","resize","addToCountAtIndex","highestEquivalentValue","valueFromIndex","bucketIndex","getBucketIndex","subBucketIndex","getSubBucketIndex","computeCountsArrayIndex","bucketBaseIndex","offsetInBucket","getValueAtPercentile","percentile","requestedPercentile","fpCountAtPercentile","getTotalCount","countAtPercentile","totalToCurrentIndex","i","getCountAtIndex","valueAtIndex","lowestEquivalentValue","valueFromIndexes","index","thisValueBaseLevel","nextNonEquivalentValue","sizeOfEquivalentValueRange","distanceToNextValue","medianEquivalentValue","getMean","reset","totalValue","hasNext","iterationValue","next","valueIteratedTo","countAtValueIteratedTo","getStdDeviation","mean","geometric_deviation_total","deviation","countAddedInThisIterationStep","std_deviation","sqrt","outputPercentileDistribution","percentileTicksPerHalfDistance","outputValueUnitScalingRatio","useCsvFormat","result","iterator","lineFormatter","lastLineFormatter","valueFormatter_1","floatFormatter","percentileFormatter_1","lastFormatter_1","percentileLevelIteratedTo","totalCountToThisValue","valueFormatter_2","percentileFormatter_2","totalCountFormatter_1","integerFormatter","lastFormatter_2","formatter","max_1","intFormatter","totalCount","getEstimatedFootprintInBytes","_getEstimatedFootprintInBytes","recordSingleValueWithExpectedInterval","expectedIntervalBetweenValueSamples","missingValue","recordCountAtValue","addToTotalCount","recordValueWithCount","recordValueWithExpectedInterval","recordValueWithCountAndExpectedInterval","addWhileCorrectingForCoordinatedOmission","otherHistogram","toHistogram","otherValues","v","add","highestRecordableValue","observedOtherTotalCount","otherCount","setTotalCount","otherMaxIndex","startTimeStampMsec","endTimeStampMsec","getCountAtValue","subtract","otherValue","establishInternalTackingValues","lengthToCover","MAX_VALUE","maxIndex","minNonZeroIndex","observedTotalCount","countAtIndex","clearCounts","tag","NO_TAG","EncodableHistogram_1","wordSizeInBytes","EncodableHistogram","TWO_POW_32","ByteBuffer","data","position","int32ArrayForConvert","Uint32Array","int8ArrayForConvert","Uint8Array","buffer","allocate","size","put","length","oldArray","set","putInt32","reverse","putInt64","putArray","array","byteLength","get","getInt32","slice","getInt64","high","low","resetPosition","AbstractHistogram_1","Int32Histogram","counts","fill","currentCount","newCount","MIN_SAFE_INTEGER","setCountAtIndex","newCounts","copyCorrectedForCoordinatedOmission","copy","ByteBuffer_1","Int32Histogram_1","base64","decodeFromCompressedBase64","base64String","histogramConstr","minBarForHighestTrackableValue","toByteArray","decodeFromCompressedByteBuffer","encodeIntoBase64String","histogram","compressionLevel","bufferSize","encodeIntoCompressedByteBuffer","encodedBuffer","fromByteArray","HistogramIterationValue_1","AbstractHistogramIterator","currentIterationValue","resetIterator","savedHistogramTotalRawCount","arrayTotalCount","currentIndex","currentValueAtIndex","nextValueAtIndex","prevValueIteratedTo","totalCountToPrevIndex","totalCountToCurrentIndex","totalValueToCurrentIndex","countAtThisValue","freshSubBucket","exhaustedSubBuckets","reachedIterationLevel","getValueIteratedTo","assign","valueIteratedFrom","totalValueToThisValue","getPercentileIteratedTo","incrementIterationLevel","incrementSubBucket","getPercentileIteratedFrom","leftPadding","input","repeat","padding","integer","fractionDigits","numberFormatter","Intl","NumberFormat","maximumFractionDigits","minimumFractionDigits","useGrouping","float","format","placeHoldersCount","b64","len","l","tmp","placeHolders","arr","Arr","L","revLookup","charCodeAt","tripletToBase64","num","lookup","encodeChunk","uint8","start","end","output","push","join","extraBytes","parts","maxChunkLength","len2","code","fillBufferFromCountsArray","self","countsLimit","srcIndex","zerosCount","ZigZagEncoding_1","encode","encodeIntoByteBuffer","initialPosition","encodingCookie","payloadStartPosition","backupIndex","fillCountsArrayFromSourceBuffer","sourceBuffer","lengthInBytes","V2maxWordSizeInBytes","dstIndex","endPosition","decode","getCookieBase","cookie","getWordSizeInBytesFromCookie","V2EncodingCookieBase","V2CompressedEncodingCookieBase","sizeByte","doDecodeFromByteBuffer","payloadLengthInBytes","lowestTrackableUnitValue","filledLength","doDecodeFromCompressedByteBuffer","initialTargetPosition","lengthOfCompressedContents","uncompressedBuffer","inflate","targetBuffer","intermediateUncompressedByteBuffer","uncompressedLength","compressedEncodingCookie","compressionOptions","level","compressedArray","deflate","decodeFromByteBuffer","Float64Histogram","Float64Array","HistogramIterationValue","encoding_1","TAG_PREFIX","TAG_PREFIX_LENGTH","HistogramLogReader","logContent","lines","splitLines","currentLineIndex","nextIntervalHistogram","rangeStartTimeSec","rangeEndTimeSec","currentLine","startsWith","parseStartTimeFromLine","parseBaseTimeFromLine","includes","tokens","split","firstToken","substring","shift","rawLogTimeStampInSec","rawIntervalLengthSec","base64Histogram","logTimeStampInSec","parseFloat","baseTimeSec","startTimeSec","intervalLengthSec","line","shouldIncludeNoTag","find","listTags","content","tags","filter","map","indexOf","tagsWithoutDuplicates","Set","from","unshift","HISTOGRAM_LOG_FORMAT_VERSION","timeFormatter","HistogramLogWriter","log","baseTime","outputIntervalHistogram","startTimeStampSec","endTimeStampSec","maxValueUnitRatio","duration","lineContent","outputComment","comment","outputStartTime","startTimeMsec","Date","outputLegend","outputLogFormatVersion","Int16Histogram","Uint16Array","Int8Histogram","AbstractHistogramIterator_1","PercentileIterator","percentileLevelToIterateTo","percentileLevelToIterateFrom","reachedLastRecordedValue","doReset","percentileReportingTicks","currentPercentile","RecordedValuesIterator","visitedIndex","Recorder","clock","getTime","activeHistogram","idGenerator","containingInstanceId","getIntervalHistogram","histogramToRecycle","histogramToRecycleWithId","inactiveHistogram","performIntervalSample","sampledHistogram","getIntervalHistogramInto","targetHistogram","tempHistogram","currentTimeInMs","TWO_POW_7","TWO_POW_14","TWO_POW_21","TWO_POW_28","TWO_POW_35","TWO_POW_42","TWO_POW_49","TWO_POW_56","ZigZagEncoding","Int8Histogram_1","Int16Histogram_1","Float64Histogram_1","Histogram","HistogramLogReader_1","HistogramLogWriter_1","Recorder_1","defaultRequest","bitBucketSize","build","request","parameters","ulp","x"],"mappings":"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","file":"hdrhistogram.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"pako\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"hdr\", [\"pako\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hdr\"] = factory(require(\"pako\"));\n\telse\n\t\troot[\"hdr\"] = factory(root[\"pako\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_8__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"pako\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"hdr\", [\"pako\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hdr\"] = factory(require(\"pako\"));\n\telse\n\t\troot[\"hdr\"] = factory(root[\"pako\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_8__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(22);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = Object.setPrototypeOf ||\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar AbstractHistogramBase_1 = __webpack_require__(2);\n\tvar RecordedValuesIterator_1 = __webpack_require__(19);\n\tvar PercentileIterator_1 = __webpack_require__(18);\n\tvar formatters_1 = __webpack_require__(7);\n\tvar ulp_1 = __webpack_require__(23);\n\tvar pow = Math.pow, floor = Math.floor, ceil = Math.ceil, log2 = Math.log2, max = Math.max, min = Math.min;\n\tvar AbstractHistogram = /** @class */ (function (_super) {\n\t    __extends(AbstractHistogram, _super);\n\t    function AbstractHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n\t        var _this = _super.call(this) || this;\n\t        _this.maxValue = 0;\n\t        _this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\n\t        // Verify argument validity\n\t        if (lowestDiscernibleValue < 1) {\n\t            throw new Error(\"lowestDiscernibleValue must be >= 1\");\n\t        }\n\t        if (highestTrackableValue < 2 * lowestDiscernibleValue) {\n\t            throw new Error(\"highestTrackableValue must be >= 2 * lowestDiscernibleValue\");\n\t        }\n\t        if (numberOfSignificantValueDigits < 0 ||\n\t            numberOfSignificantValueDigits > 5) {\n\t            throw new Error(\"numberOfSignificantValueDigits must be between 0 and 5\");\n\t        }\n\t        _this.identity = AbstractHistogramBase_1.AbstractHistogramBase.identityBuilder++;\n\t        _this.init(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, 1.0, 0);\n\t        return _this;\n\t    }\n\t    AbstractHistogram.prototype.updatedMaxValue = function (value) {\n\t        var internalValue = value + this.unitMagnitudeMask;\n\t        this.maxValue = internalValue;\n\t    };\n\t    AbstractHistogram.prototype.updateMinNonZeroValue = function (value) {\n\t        if (value <= this.unitMagnitudeMask) {\n\t            return;\n\t        }\n\t        var internalValue = floor(value / this.lowestDiscernibleValueRounded) *\n\t            this.lowestDiscernibleValueRounded;\n\t        this.minNonZeroValue = internalValue;\n\t    };\n\t    AbstractHistogram.prototype.resetMinNonZeroValue = function (minNonZeroValue) {\n\t        var internalValue = floor(minNonZeroValue / this.lowestDiscernibleValueRounded) *\n\t            this.lowestDiscernibleValueRounded;\n\t        this.minNonZeroValue =\n\t            minNonZeroValue === Number.MAX_SAFE_INTEGER\n\t                ? minNonZeroValue\n\t                : internalValue;\n\t    };\n\t    AbstractHistogram.prototype.init = function (lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, integerToDoubleValueConversionRatio, normalizingIndexOffset) {\n\t        this.lowestDiscernibleValue = lowestDiscernibleValue;\n\t        this.highestTrackableValue = highestTrackableValue;\n\t        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\n\t        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\n\t        if (normalizingIndexOffset !== 0) {\n\t            this.setNormalizingIndexOffset(normalizingIndexOffset);\n\t        }\n\t        /*\n\t        * Given a 3 decimal point accuracy, the expectation is obviously for \"+/- 1 unit at 1000\". It also means that\n\t        * it's \"ok to be +/- 2 units at 2000\". The \"tricky\" thing is that it is NOT ok to be +/- 2 units at 1999. Only\n\t        * starting at 2000. So internally, we need to maintain single unit resolution to 2x 10^decimalPoints.\n\t        */\n\t        var largestValueWithSingleUnitResolution = 2 * floor(pow(10, numberOfSignificantValueDigits));\n\t        this.unitMagnitude = floor(log2(lowestDiscernibleValue));\n\t        this.lowestDiscernibleValueRounded = pow(2, this.unitMagnitude);\n\t        this.unitMagnitudeMask = this.lowestDiscernibleValueRounded - 1;\n\t        // We need to maintain power-of-two subBucketCount (for clean direct indexing) that is large enough to\n\t        // provide unit resolution to at least largestValueWithSingleUnitResolution. So figure out\n\t        // largestValueWithSingleUnitResolution's nearest power-of-two (rounded up), and use that:\n\t        var subBucketCountMagnitude = ceil(log2(largestValueWithSingleUnitResolution));\n\t        this.subBucketHalfCountMagnitude =\n\t            (subBucketCountMagnitude > 1 ? subBucketCountMagnitude : 1) - 1;\n\t        this.subBucketCount = pow(2, this.subBucketHalfCountMagnitude + 1);\n\t        this.subBucketHalfCount = this.subBucketCount / 2;\n\t        this.subBucketMask =\n\t            (floor(this.subBucketCount) - 1) * pow(2, this.unitMagnitude);\n\t        this.establishSize(highestTrackableValue);\n\t        this.leadingZeroCountBase =\n\t            53 - this.unitMagnitude - this.subBucketHalfCountMagnitude - 1;\n\t        this.percentileIterator = new PercentileIterator_1.default(this, 1);\n\t        this.recordedValuesIterator = new RecordedValuesIterator_1.default(this);\n\t    };\n\t    /**\n\t     * The buckets (each of which has subBucketCount sub-buckets, here assumed to be 2048 as an example) overlap:\n\t     *\n\t     * <pre>\n\t     * The 0'th bucket covers from 0...2047 in multiples of 1, using all 2048 sub-buckets\n\t     * The 1'th bucket covers from 2048..4097 in multiples of 2, using only the top 1024 sub-buckets\n\t     * The 2'th bucket covers from 4096..8191 in multiple of 4, using only the top 1024 sub-buckets\n\t     * ...\n\t     * </pre>\n\t     *\n\t     * Bucket 0 is \"special\" here. It is the only one that has 2048 entries. All the rest have 1024 entries (because\n\t     * their bottom half overlaps with and is already covered by the all of the previous buckets put together). In other\n\t     * words, the k'th bucket could represent 0 * 2^k to 2048 * 2^k in 2048 buckets with 2^k precision, but the midpoint\n\t     * of 1024 * 2^k = 2048 * 2^(k-1) = the k-1'th bucket's end, so we would use the previous bucket for those lower\n\t     * values as it has better precision.\n\t     */\n\t    AbstractHistogram.prototype.establishSize = function (newHighestTrackableValue) {\n\t        // establish counts array length:\n\t        this.countsArrayLength = this.determineArrayLengthNeeded(newHighestTrackableValue);\n\t        // establish exponent range needed to support the trackable value with no overflow:\n\t        this.bucketCount = this.getBucketsNeededToCoverValue(newHighestTrackableValue);\n\t        // establish the new highest trackable value:\n\t        this.highestTrackableValue = newHighestTrackableValue;\n\t    };\n\t    AbstractHistogram.prototype.determineArrayLengthNeeded = function (highestTrackableValue) {\n\t        if (highestTrackableValue < 2 * this.lowestDiscernibleValue) {\n\t            throw new Error(\"highestTrackableValue (\" +\n\t                highestTrackableValue +\n\t                \") cannot be < (2 * lowestDiscernibleValue)\");\n\t        }\n\t        //determine counts array length needed:\n\t        var countsArrayLength = this.getLengthForNumberOfBuckets(this.getBucketsNeededToCoverValue(highestTrackableValue));\n\t        return countsArrayLength;\n\t    };\n\t    /**\n\t     * If we have N such that subBucketCount * 2^N > max value, we need storage for N+1 buckets, each with enough\n\t     * slots to hold the top half of the subBucketCount (the lower half is covered by previous buckets), and the +1\n\t     * being used for the lower half of the 0'th bucket. Or, equivalently, we need 1 more bucket to capture the max\n\t     * value if we consider the sub-bucket length to be halved.\n\t     */\n\t    AbstractHistogram.prototype.getLengthForNumberOfBuckets = function (numberOfBuckets) {\n\t        var lengthNeeded = (numberOfBuckets + 1) * (this.subBucketCount / 2);\n\t        return lengthNeeded;\n\t    };\n\t    AbstractHistogram.prototype.getBucketsNeededToCoverValue = function (value) {\n\t        // the k'th bucket can express from 0 * 2^k to subBucketCount * 2^k in units of 2^k\n\t        var smallestUntrackableValue = this.subBucketCount * pow(2, this.unitMagnitude);\n\t        // always have at least 1 bucket\n\t        var bucketsNeeded = 1;\n\t        while (smallestUntrackableValue <= value) {\n\t            if (smallestUntrackableValue > Number.MAX_SAFE_INTEGER / 2) {\n\t                // TODO check array max size in JavaScript\n\t                // next shift will overflow, meaning that bucket could represent values up to ones greater than\n\t                // Number.MAX_SAFE_INTEGER, so it's the last bucket\n\t                return bucketsNeeded + 1;\n\t            }\n\t            smallestUntrackableValue = smallestUntrackableValue * 2;\n\t            bucketsNeeded++;\n\t        }\n\t        return bucketsNeeded;\n\t    };\n\t    /**\n\t     * Record a value in the histogram\n\t     *\n\t     * @param value The value to be recorded\n\t     * @throws may throw Error if value is exceeds highestTrackableValue\n\t     */\n\t    AbstractHistogram.prototype.recordValue = function (value) {\n\t        this.recordSingleValue(value);\n\t    };\n\t    AbstractHistogram.prototype.recordSingleValue = function (value) {\n\t        var countsIndex = this.countsArrayIndex(value);\n\t        if (countsIndex >= this.countsArrayLength) {\n\t            this.handleRecordException(1, value);\n\t        }\n\t        else {\n\t            this.incrementCountAtIndex(countsIndex);\n\t        }\n\t        this.updateMinAndMax(value);\n\t        this.incrementTotalCount();\n\t    };\n\t    AbstractHistogram.prototype.handleRecordException = function (count, value) {\n\t        if (!this.autoResize) {\n\t            throw new Error(\"Value \" + value + \" is outside of histogram covered range\");\n\t        }\n\t        this.resize(value);\n\t        var countsIndex = this.countsArrayIndex(value);\n\t        this.addToCountAtIndex(countsIndex, count);\n\t        this.highestTrackableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\n\t    };\n\t    AbstractHistogram.prototype.countsArrayIndex = function (value) {\n\t        if (value < 0) {\n\t            throw new Error(\"Histogram recorded value cannot be negative.\");\n\t        }\n\t        var bucketIndex = this.getBucketIndex(value);\n\t        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n\t        return this.computeCountsArrayIndex(bucketIndex, subBucketIndex);\n\t    };\n\t    AbstractHistogram.prototype.computeCountsArrayIndex = function (bucketIndex, subBucketIndex) {\n\t        // TODO\n\t        //assert(subBucketIndex < subBucketCount);\n\t        //assert(bucketIndex == 0 || (subBucketIndex >= subBucketHalfCount));\n\t        // Calculate the index for the first entry that will be used in the bucket (halfway through subBucketCount).\n\t        // For bucketIndex 0, all subBucketCount entries may be used, but bucketBaseIndex is still set in the middle.\n\t        var bucketBaseIndex = (bucketIndex + 1) * pow(2, this.subBucketHalfCountMagnitude);\n\t        // Calculate the offset in the bucket. This subtraction will result in a positive value in all buckets except\n\t        // the 0th bucket (since a value in that bucket may be less than half the bucket's 0 to subBucketCount range).\n\t        // However, this works out since we give bucket 0 twice as much space.\n\t        var offsetInBucket = subBucketIndex - this.subBucketHalfCount;\n\t        // The following is the equivalent of ((subBucketIndex  - subBucketHalfCount) + bucketBaseIndex;\n\t        return bucketBaseIndex + offsetInBucket;\n\t    };\n\t    /**\n\t     * @return the lowest (and therefore highest precision) bucket index that can represent the value\n\t     */\n\t    AbstractHistogram.prototype.getBucketIndex = function (value) {\n\t        // Calculates the number of powers of two by which the value is greater than the biggest value that fits in\n\t        // bucket 0. This is the bucket index since each successive bucket can hold a value 2x greater.\n\t        // The mask maps small values to bucket 0.\n\t        // return this.leadingZeroCountBase - Long.numberOfLeadingZeros(value | subBucketMask);\n\t        return max(floor(log2(value)) -\n\t            this.subBucketHalfCountMagnitude -\n\t            this.unitMagnitude, 0);\n\t    };\n\t    AbstractHistogram.prototype.getSubBucketIndex = function (value, bucketIndex) {\n\t        // For bucketIndex 0, this is just value, so it may be anywhere in 0 to subBucketCount.\n\t        // For other bucketIndex, this will always end up in the top half of subBucketCount: assume that for some bucket\n\t        // k > 0, this calculation will yield a value in the bottom half of 0 to subBucketCount. Then, because of how\n\t        // buckets overlap, it would have also been in the top half of bucket k-1, and therefore would have\n\t        // returned k-1 in getBucketIndex(). Since we would then shift it one fewer bits here, it would be twice as big,\n\t        // and therefore in the top half of subBucketCount.\n\t        return floor(value / pow(2, bucketIndex + this.unitMagnitude));\n\t    };\n\t    AbstractHistogram.prototype.updateMinAndMax = function (value) {\n\t        if (value > this.maxValue) {\n\t            this.updatedMaxValue(value);\n\t        }\n\t        if (value < this.minNonZeroValue && value !== 0) {\n\t            this.updateMinNonZeroValue(value);\n\t        }\n\t    };\n\t    /**\n\t     * Get the value at a given percentile.\n\t     * When the given percentile is &gt; 0.0, the value returned is the value that the given\n\t     * percentage of the overall recorded value entries in the histogram are either smaller than\n\t     * or equivalent to. When the given percentile is 0.0, the value returned is the value that all value\n\t     * entries in the histogram are either larger than or equivalent to.\n\t     * <p>\n\t     * Note that two values are \"equivalent\" in this statement if\n\t     * {@link org.HdrHistogram.AbstractHistogram#valuesAreEquivalent} would return true.\n\t     *\n\t     * @param percentile  The percentile for which to return the associated value\n\t     * @return The value that the given percentage of the overall recorded value entries in the\n\t     * histogram are either smaller than or equivalent to. When the percentile is 0.0, returns the\n\t     * value that all value entries in the histogram are either larger than or equivalent to.\n\t     */\n\t    AbstractHistogram.prototype.getValueAtPercentile = function (percentile) {\n\t        var requestedPercentile = min(percentile, 100); // Truncate down to 100%\n\t        // round count up to nearest integer, to ensure that the largest value that the requested percentile\n\t        // of overall recorded values is actually included. However, this must be done with care:\n\t        //\n\t        // First, Compute fp value for count at the requested percentile. Note that fp result end up\n\t        // being 1 ulp larger than the correct integer count for this percentile:\n\t        var fpCountAtPercentile = requestedPercentile / 100.0 * this.getTotalCount();\n\t        // Next, round up, but make sure to prevent <= 1 ulp inaccurancies in the above fp math from\n\t        // making us skip a count:\n\t        var countAtPercentile = max(ceil(fpCountAtPercentile - ulp_1.default(fpCountAtPercentile)), // round up\n\t        1 // Make sure we at least reach the first recorded entry\n\t        );\n\t        var totalToCurrentIndex = 0;\n\t        for (var i = 0; i < this.countsArrayLength; i++) {\n\t            totalToCurrentIndex += this.getCountAtIndex(i);\n\t            if (totalToCurrentIndex >= countAtPercentile) {\n\t                var valueAtIndex = this.valueFromIndex(i);\n\t                return percentile === 0.0\n\t                    ? this.lowestEquivalentValue(valueAtIndex)\n\t                    : this.highestEquivalentValue(valueAtIndex);\n\t            }\n\t        }\n\t        return 0;\n\t    };\n\t    AbstractHistogram.prototype.valueFromIndexes = function (bucketIndex, subBucketIndex) {\n\t        return subBucketIndex * pow(2, bucketIndex + this.unitMagnitude);\n\t    };\n\t    AbstractHistogram.prototype.valueFromIndex = function (index) {\n\t        var bucketIndex = floor(index / this.subBucketHalfCount) - 1;\n\t        var subBucketIndex = index % this.subBucketHalfCount + this.subBucketHalfCount;\n\t        if (bucketIndex < 0) {\n\t            subBucketIndex -= this.subBucketHalfCount;\n\t            bucketIndex = 0;\n\t        }\n\t        return this.valueFromIndexes(bucketIndex, subBucketIndex);\n\t    };\n\t    /**\n\t     * Get the lowest value that is equivalent to the given value within the histogram's resolution.\n\t     * Where \"equivalent\" means that value samples recorded for any two\n\t     * equivalent values are counted in a common total count.\n\t     *\n\t     * @param value The given value\n\t     * @return The lowest value that is equivalent to the given value within the histogram's resolution.\n\t     */\n\t    AbstractHistogram.prototype.lowestEquivalentValue = function (value) {\n\t        var bucketIndex = this.getBucketIndex(value);\n\t        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n\t        var thisValueBaseLevel = this.valueFromIndexes(bucketIndex, subBucketIndex);\n\t        return thisValueBaseLevel;\n\t    };\n\t    /**\n\t     * Get the highest value that is equivalent to the given value within the histogram's resolution.\n\t     * Where \"equivalent\" means that value samples recorded for any two\n\t     * equivalent values are counted in a common total count.\n\t     *\n\t     * @param value The given value\n\t     * @return The highest value that is equivalent to the given value within the histogram's resolution.\n\t     */\n\t    AbstractHistogram.prototype.highestEquivalentValue = function (value) {\n\t        return this.nextNonEquivalentValue(value) - 1;\n\t    };\n\t    /**\n\t     * Get the next value that is not equivalent to the given value within the histogram's resolution.\n\t     * Where \"equivalent\" means that value samples recorded for any two\n\t     * equivalent values are counted in a common total count.\n\t     *\n\t     * @param value The given value\n\t     * @return The next value that is not equivalent to the given value within the histogram's resolution.\n\t     */\n\t    AbstractHistogram.prototype.nextNonEquivalentValue = function (value) {\n\t        return (this.lowestEquivalentValue(value) + this.sizeOfEquivalentValueRange(value));\n\t    };\n\t    /**\n\t     * Get the size (in value units) of the range of values that are equivalent to the given value within the\n\t     * histogram's resolution. Where \"equivalent\" means that value samples recorded for any two\n\t     * equivalent values are counted in a common total count.\n\t     *\n\t     * @param value The given value\n\t     * @return The size of the range of values equivalent to the given value.\n\t     */\n\t    AbstractHistogram.prototype.sizeOfEquivalentValueRange = function (value) {\n\t        var bucketIndex = this.getBucketIndex(value);\n\t        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n\t        var distanceToNextValue = pow(2, this.unitMagnitude +\n\t            (subBucketIndex >= this.subBucketCount ? bucketIndex + 1 : bucketIndex));\n\t        return distanceToNextValue;\n\t    };\n\t    /**\n\t     * Get a value that lies in the middle (rounded up) of the range of values equivalent the given value.\n\t     * Where \"equivalent\" means that value samples recorded for any two\n\t     * equivalent values are counted in a common total count.\n\t     *\n\t     * @param value The given value\n\t     * @return The value lies in the middle (rounded up) of the range of values equivalent the given value.\n\t     */\n\t    AbstractHistogram.prototype.medianEquivalentValue = function (value) {\n\t        return (this.lowestEquivalentValue(value) +\n\t            floor(this.sizeOfEquivalentValueRange(value) / 2));\n\t    };\n\t    /**\n\t     * Get the computed mean value of all recorded values in the histogram\n\t     *\n\t     * @return the mean value (in value units) of the histogram data\n\t     */\n\t    AbstractHistogram.prototype.getMean = function () {\n\t        if (this.getTotalCount() === 0) {\n\t            return 0;\n\t        }\n\t        this.recordedValuesIterator.reset();\n\t        var totalValue = 0;\n\t        while (this.recordedValuesIterator.hasNext()) {\n\t            var iterationValue = this.recordedValuesIterator.next();\n\t            totalValue +=\n\t                this.medianEquivalentValue(iterationValue.valueIteratedTo) *\n\t                    iterationValue.countAtValueIteratedTo;\n\t        }\n\t        return totalValue * 1.0 / this.getTotalCount();\n\t    };\n\t    /**\n\t     * Get the computed standard deviation of all recorded values in the histogram\n\t     *\n\t     * @return the standard deviation (in value units) of the histogram data\n\t     */\n\t    AbstractHistogram.prototype.getStdDeviation = function () {\n\t        if (this.getTotalCount() === 0) {\n\t            return 0;\n\t        }\n\t        var mean = this.getMean();\n\t        var geometric_deviation_total = 0.0;\n\t        this.recordedValuesIterator.reset();\n\t        while (this.recordedValuesIterator.hasNext()) {\n\t            var iterationValue = this.recordedValuesIterator.next();\n\t            var deviation = this.medianEquivalentValue(iterationValue.valueIteratedTo) - mean;\n\t            geometric_deviation_total +=\n\t                deviation * deviation * iterationValue.countAddedInThisIterationStep;\n\t        }\n\t        var std_deviation = Math.sqrt(geometric_deviation_total / this.getTotalCount());\n\t        return std_deviation;\n\t    };\n\t    /**\n\t     * Produce textual representation of the value distribution of histogram data by percentile. The distribution is\n\t     * output with exponentially increasing resolution, with each exponentially decreasing half-distance containing\n\t     * <i>dumpTicksPerHalf</i> percentile reporting tick points.\n\t     *\n\t     * @param printStream    Stream into which the distribution will be output\n\t     * <p>\n\t     * @param percentileTicksPerHalfDistance  The number of reporting points per exponentially decreasing half-distance\n\t     * <p>\n\t     * @param outputValueUnitScalingRatio    The scaling factor by which to divide histogram recorded values units in\n\t     *                                     output\n\t     * @param useCsvFormat  Output in CSV format if true. Otherwise use plain text form.\n\t     */\n\t    AbstractHistogram.prototype.outputPercentileDistribution = function (percentileTicksPerHalfDistance, outputValueUnitScalingRatio, useCsvFormat) {\n\t        if (percentileTicksPerHalfDistance === void 0) { percentileTicksPerHalfDistance = 5; }\n\t        if (outputValueUnitScalingRatio === void 0) { outputValueUnitScalingRatio = 1; }\n\t        if (useCsvFormat === void 0) { useCsvFormat = false; }\n\t        var result = \"\";\n\t        if (useCsvFormat) {\n\t            result += '\"Value\",\"Percentile\",\"TotalCount\",\"1/(1-Percentile)\"\\n';\n\t        }\n\t        else {\n\t            result += \"       Value     Percentile TotalCount 1/(1-Percentile)\\n\\n\";\n\t        }\n\t        var iterator = this.percentileIterator;\n\t        iterator.reset(percentileTicksPerHalfDistance);\n\t        var lineFormatter;\n\t        var lastLineFormatter;\n\t        if (useCsvFormat) {\n\t            var valueFormatter_1 = formatters_1.floatFormatter(0, this.numberOfSignificantValueDigits);\n\t            var percentileFormatter_1 = formatters_1.floatFormatter(0, 12);\n\t            var lastFormatter_1 = formatters_1.floatFormatter(0, 2);\n\t            lineFormatter = function (iterationValue) {\n\t                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n\t                    \",\" +\n\t                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\n\t                    \",\" +\n\t                    iterationValue.totalCountToThisValue +\n\t                    \",\" +\n\t                    lastFormatter_1(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\n\t                    \"\\n\";\n\t            };\n\t            lastLineFormatter = function (iterationValue) {\n\t                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n\t                    \",\" +\n\t                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\n\t                    \",\" +\n\t                    iterationValue.totalCountToThisValue +\n\t                    \",Infinity\\n\";\n\t            };\n\t        }\n\t        else {\n\t            var valueFormatter_2 = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\n\t            var percentileFormatter_2 = formatters_1.floatFormatter(2, 12);\n\t            var totalCountFormatter_1 = formatters_1.integerFormatter(10);\n\t            var lastFormatter_2 = formatters_1.floatFormatter(14, 2);\n\t            lineFormatter = function (iterationValue) {\n\t                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n\t                    \" \" +\n\t                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\n\t                    \" \" +\n\t                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\n\t                    \" \" +\n\t                    lastFormatter_2(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\n\t                    \"\\n\";\n\t            };\n\t            lastLineFormatter = function (iterationValue) {\n\t                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n\t                    \" \" +\n\t                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\n\t                    \" \" +\n\t                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\n\t                    \"\\n\";\n\t            };\n\t        }\n\t        while (iterator.hasNext()) {\n\t            var iterationValue = iterator.next();\n\t            if (iterationValue.percentileLevelIteratedTo < 100) {\n\t                result += lineFormatter(iterationValue);\n\t            }\n\t            else {\n\t                result += lastLineFormatter(iterationValue);\n\t            }\n\t        }\n\t        if (!useCsvFormat) {\n\t            // Calculate and output mean and std. deviation.\n\t            // Note: mean/std. deviation numbers are very often completely irrelevant when\n\t            // data is extremely non-normal in distribution (e.g. in cases of strong multi-modal\n\t            // response time distribution associated with GC pauses). However, reporting these numbers\n\t            // can be very useful for contrasting with the detailed percentile distribution\n\t            // reported by outputPercentileDistribution(). It is not at all surprising to find\n\t            // percentile distributions where results fall many tens or even hundreds of standard\n\t            // deviations away from the mean - such results simply indicate that the data sampled\n\t            // exhibits a very non-normal distribution, highlighting situations for which the std.\n\t            // deviation metric is a useless indicator.\n\t            //\n\t            var formatter = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\n\t            var mean = formatter(this.getMean() / outputValueUnitScalingRatio);\n\t            var std_deviation = formatter(this.getStdDeviation() / outputValueUnitScalingRatio);\n\t            var max_1 = formatter(this.maxValue / outputValueUnitScalingRatio);\n\t            var intFormatter = formatters_1.integerFormatter(12);\n\t            var totalCount = intFormatter(this.getTotalCount());\n\t            var bucketCount = intFormatter(this.bucketCount);\n\t            var subBucketCount = intFormatter(this.subBucketCount);\n\t            result += \"#[Mean    = \" + mean + \", StdDeviation   = \" + std_deviation + \"]\\n#[Max     = \" + max_1 + \", Total count    = \" + totalCount + \"]\\n#[Buckets = \" + bucketCount + \", SubBuckets     = \" + subBucketCount + \"]\\n\";\n\t        }\n\t        return result;\n\t    };\n\t    /**\n\t     * Provide a (conservatively high) estimate of the Histogram's total footprint in bytes\n\t     *\n\t     * @return a (conservatively high) estimate of the Histogram's total footprint in bytes\n\t     */\n\t    AbstractHistogram.prototype.getEstimatedFootprintInBytes = function () {\n\t        return this._getEstimatedFootprintInBytes();\n\t    };\n\t    AbstractHistogram.prototype.recordSingleValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n\t        this.recordSingleValue(value);\n\t        if (expectedIntervalBetweenValueSamples <= 0) {\n\t            return;\n\t        }\n\t        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\n\t            this.recordSingleValue(missingValue);\n\t        }\n\t    };\n\t    AbstractHistogram.prototype.recordCountAtValue = function (count, value) {\n\t        var countsIndex = this.countsArrayIndex(value);\n\t        if (countsIndex >= this.countsArrayLength) {\n\t            this.handleRecordException(count, value);\n\t        }\n\t        else {\n\t            this.addToCountAtIndex(countsIndex, count);\n\t        }\n\t        this.updateMinAndMax(value);\n\t        this.addToTotalCount(count);\n\t    };\n\t    /**\n\t     * Record a value in the histogram (adding to the value's current count)\n\t     *\n\t     * @param value The value to be recorded\n\t     * @param count The number of occurrences of this value to record\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n\t     */\n\t    AbstractHistogram.prototype.recordValueWithCount = function (value, count) {\n\t        this.recordCountAtValue(count, value);\n\t    };\n\t    /**\n\t     * Record a value in the histogram.\n\t     * <p>\n\t     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n\t     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\n\t     * (down to the expectedIntervalBetweenValueSamples) value records.\n\t     * <p>\n\t     * Note: This is a at-recording correction method, as opposed to the post-recording correction method provided\n\t     * by {@link #copyCorrectedForCoordinatedOmission(long)}.\n\t     * The two methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\n\t     * for the same coordinated omission issue.\n\t     * <p>\n\t     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\n\t     * important.\n\t     *\n\t     * @param value The value to record\n\t     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n\t     *                                           auto-generated value records as appropriate if value is larger\n\t     *                                           than expectedIntervalBetweenValueSamples\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n\t     */\n\t    AbstractHistogram.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n\t        this.recordSingleValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\n\t    };\n\t    AbstractHistogram.prototype.recordValueWithCountAndExpectedInterval = function (value, count, expectedIntervalBetweenValueSamples) {\n\t        this.recordCountAtValue(count, value);\n\t        if (expectedIntervalBetweenValueSamples <= 0) {\n\t            return;\n\t        }\n\t        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\n\t            this.recordCountAtValue(count, missingValue);\n\t        }\n\t    };\n\t    /**\n\t     * Add the contents of another histogram to this one, while correcting the incoming data for coordinated omission.\n\t     * <p>\n\t     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n\t     * interval between value samples, the values added will include an auto-generated additional series of\n\t     * decreasingly-smaller (down to the expectedIntervalBetweenValueSamples) value records for each count found\n\t     * in the current histogram that is larger than the expectedIntervalBetweenValueSamples.\n\t     *\n\t     * Note: This is a post-recording correction method, as opposed to the at-recording correction method provided\n\t     * by {@link #recordValueWithExpectedInterval(long, long) recordValueWithExpectedInterval}. The two\n\t     * methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\n\t     * for the same coordinated omission issue.\n\t     * by\n\t     * <p>\n\t     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\n\t     * important.\n\t     *\n\t     * @param otherHistogram The other histogram. highestTrackableValue and largestValueWithSingleUnitResolution must match.\n\t     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n\t     *                                           auto-generated value records as appropriate if value is larger\n\t     *                                           than expectedIntervalBetweenValueSamples\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if values exceed highestTrackableValue\n\t     */\n\t    AbstractHistogram.prototype.addWhileCorrectingForCoordinatedOmission = function (otherHistogram, expectedIntervalBetweenValueSamples) {\n\t        var toHistogram = this;\n\t        var otherValues = new RecordedValuesIterator_1.default(otherHistogram);\n\t        while (otherValues.hasNext()) {\n\t            var v = otherValues.next();\n\t            toHistogram.recordValueWithCountAndExpectedInterval(v.valueIteratedTo, v.countAtValueIteratedTo, expectedIntervalBetweenValueSamples);\n\t        }\n\t    };\n\t    /**\n\t     * Add the contents of another histogram to this one.\n\t     * <p>\n\t     * As part of adding the contents, the start/end timestamp range of this histogram will be\n\t     * extended to include the start/end timestamp range of the other histogram.\n\t     *\n\t     * @param otherHistogram The other histogram.\n\t     * @throws (may throw) if values in fromHistogram's are\n\t     * higher than highestTrackableValue.\n\t     */\n\t    AbstractHistogram.prototype.add = function (otherHistogram) {\n\t        var highestRecordableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\n\t        if (highestRecordableValue < otherHistogram.maxValue) {\n\t            if (!this.autoResize) {\n\t                throw new Error(\"The other histogram includes values that do not fit in this histogram's range.\");\n\t            }\n\t            this.resize(otherHistogram.maxValue);\n\t        }\n\t        if (this.bucketCount === otherHistogram.bucketCount &&\n\t            this.subBucketCount === otherHistogram.subBucketCount &&\n\t            this.unitMagnitude === otherHistogram.unitMagnitude) {\n\t            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\n\t            var observedOtherTotalCount = 0;\n\t            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n\t                var otherCount = otherHistogram.getCountAtIndex(i);\n\t                if (otherCount > 0) {\n\t                    this.addToCountAtIndex(i, otherCount);\n\t                    observedOtherTotalCount += otherCount;\n\t                }\n\t            }\n\t            this.setTotalCount(this.getTotalCount() + observedOtherTotalCount);\n\t            this.updatedMaxValue(max(this.maxValue, otherHistogram.maxValue));\n\t            this.updateMinNonZeroValue(min(this.minNonZeroValue, otherHistogram.minNonZeroValue));\n\t        }\n\t        else {\n\t            // Arrays are not a direct match (or the other could change on the fly in some valid way),\n\t            // so we can't just stream through and add them. Instead, go through the array and add each\n\t            // non-zero value found at it's proper value:\n\t            // Do max value first, to avoid max value updates on each iteration:\n\t            var otherMaxIndex = otherHistogram.countsArrayIndex(otherHistogram.maxValue);\n\t            var otherCount = otherHistogram.getCountAtIndex(otherMaxIndex);\n\t            this.recordCountAtValue(otherCount, otherHistogram.maxValue);\n\t            // Record the remaining values, up to but not including the max value:\n\t            for (var i = 0; i < otherMaxIndex; i++) {\n\t                otherCount = otherHistogram.getCountAtIndex(i);\n\t                if (otherCount > 0) {\n\t                    this.recordCountAtValue(otherCount, otherHistogram.valueFromIndex(i));\n\t                }\n\t            }\n\t        }\n\t        this.startTimeStampMsec = min(this.startTimeStampMsec, otherHistogram.startTimeStampMsec);\n\t        this.endTimeStampMsec = max(this.endTimeStampMsec, otherHistogram.endTimeStampMsec);\n\t    };\n\t    /**\n\t     * Get the count of recorded values at a specific value (to within the histogram resolution at the value level).\n\t     *\n\t     * @param value The value for which to provide the recorded count\n\t     * @return The total count of values recorded in the histogram within the value range that is\n\t     * {@literal >=} lowestEquivalentValue(<i>value</i>) and {@literal <=} highestEquivalentValue(<i>value</i>)\n\t     */\n\t    AbstractHistogram.prototype.getCountAtValue = function (value) {\n\t        var index = min(max(0, this.countsArrayIndex(value)), this.countsArrayLength - 1);\n\t        return this.getCountAtIndex(index);\n\t    };\n\t    /**\n\t     * Subtract the contents of another histogram from this one.\n\t     * <p>\n\t     * The start/end timestamps of this histogram will remain unchanged.\n\t     *\n\t     * @param otherHistogram The other histogram.\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if values in otherHistogram's are higher than highestTrackableValue.\n\t     *\n\t     */\n\t    AbstractHistogram.prototype.subtract = function (otherHistogram) {\n\t        var highestRecordableValue = this.valueFromIndex(this.countsArrayLength - 1);\n\t        if (highestRecordableValue < otherHistogram.maxValue) {\n\t            if (!this.autoResize) {\n\t                throw new Error(\"The other histogram includes values that do not fit in this histogram's range.\");\n\t            }\n\t            this.resize(otherHistogram.maxValue);\n\t        }\n\t        if (this.bucketCount === otherHistogram.bucketCount &&\n\t            this.subBucketCount === otherHistogram.subBucketCount &&\n\t            this.unitMagnitude === otherHistogram.unitMagnitude) {\n\t            // optim\n\t            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\n\t            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n\t                var otherCount = otherHistogram.getCountAtIndex(i);\n\t                if (otherCount > 0) {\n\t                    this.addToCountAtIndex(i, -otherCount);\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n\t                var otherCount = otherHistogram.getCountAtIndex(i);\n\t                if (otherCount > 0) {\n\t                    var otherValue = otherHistogram.valueFromIndex(i);\n\t                    if (this.getCountAtValue(otherValue) < otherCount) {\n\t                        throw new Error(\"otherHistogram count (\" +\n\t                            otherCount +\n\t                            \") at value \" +\n\t                            otherValue +\n\t                            \" is larger than this one's (\" +\n\t                            this.getCountAtValue(otherValue) +\n\t                            \")\");\n\t                    }\n\t                    this.recordCountAtValue(-otherCount, otherValue);\n\t                }\n\t            }\n\t        }\n\t        // With subtraction, the max and minNonZero values could have changed:\n\t        if (this.getCountAtValue(this.maxValue) <= 0 ||\n\t            this.getCountAtValue(this.minNonZeroValue) <= 0) {\n\t            this.establishInternalTackingValues();\n\t        }\n\t    };\n\t    AbstractHistogram.prototype.establishInternalTackingValues = function (lengthToCover) {\n\t        if (lengthToCover === void 0) { lengthToCover = this.countsArrayLength; }\n\t        this.maxValue = 0;\n\t        this.minNonZeroValue = Number.MAX_VALUE;\n\t        var maxIndex = -1;\n\t        var minNonZeroIndex = -1;\n\t        var observedTotalCount = 0;\n\t        for (var index = 0; index < lengthToCover; index++) {\n\t            var countAtIndex = this.getCountAtIndex(index);\n\t            if (countAtIndex > 0) {\n\t                observedTotalCount += countAtIndex;\n\t                maxIndex = index;\n\t                if (minNonZeroIndex == -1 && index != 0) {\n\t                    minNonZeroIndex = index;\n\t                }\n\t            }\n\t        }\n\t        if (maxIndex >= 0) {\n\t            this.updatedMaxValue(this.highestEquivalentValue(this.valueFromIndex(maxIndex)));\n\t        }\n\t        if (minNonZeroIndex >= 0) {\n\t            this.updateMinNonZeroValue(this.valueFromIndex(minNonZeroIndex));\n\t        }\n\t        this.setTotalCount(observedTotalCount);\n\t    };\n\t    AbstractHistogram.prototype.reset = function () {\n\t        this.clearCounts();\n\t        this.setTotalCount(0);\n\t        this.startTimeStampMsec = 0;\n\t        this.endTimeStampMsec = 0;\n\t        this.tag = AbstractHistogramBase_1.NO_TAG;\n\t        this.maxValue = 0;\n\t        this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\n\t    };\n\t    return AbstractHistogram;\n\t}(AbstractHistogramBase_1.AbstractHistogramBase));\n\texports.AbstractHistogram = AbstractHistogram;\n\texports.default = AbstractHistogram;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = Object.setPrototypeOf ||\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar EncodableHistogram_1 = __webpack_require__(11);\n\texports.NO_TAG = \"NO TAG\";\n\tvar AbstractHistogramBase = /** @class */ (function (_super) {\n\t    __extends(AbstractHistogramBase, _super);\n\t    //intermediateUncompressedByteBuffer : ByteBuffer = null;\n\t    //intermediateUncompressedByteArray : number[] = null;\n\t    /* useless ?\n\t    getIntegerToDoubleValueConversionRatio(): number {\n\t        return this.integerToDoubleValueConversionRatio;\n\t    }\n\t  \n\t    setIntegerToDoubleValueConversionRatio(integerToDoubleValueConversionRatio: number) {\n\t        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\n\t    }*/\n\t    function AbstractHistogramBase() {\n\t        var _this = _super.call(this) || this;\n\t        _this.autoResize = false;\n\t        _this.startTimeStampMsec = Number.MAX_SAFE_INTEGER;\n\t        _this.endTimeStampMsec = 0;\n\t        _this.tag = exports.NO_TAG;\n\t        _this.integerToDoubleValueConversionRatio = 1.0;\n\t        _this.identity = 0;\n\t        _this.highestTrackableValue = 0;\n\t        _this.lowestDiscernibleValue = 0;\n\t        _this.numberOfSignificantValueDigits = 0;\n\t        _this.bucketCount = 0;\n\t        _this.subBucketCount = 0;\n\t        _this.countsArrayLength = 0;\n\t        _this.wordSizeInBytes = 0;\n\t        return _this;\n\t    }\n\t    return AbstractHistogramBase;\n\t}(EncodableHistogram_1.EncodableHistogram));\n\texports.AbstractHistogramBase = AbstractHistogramBase;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar pow = Math.pow, floor = Math.floor;\n\tvar TWO_POW_32 = pow(2, 32);\n\t/**\n\t * Mimic Java's ByteBufffer with big endian order\n\t */\n\tvar ByteBuffer = /** @class */ (function () {\n\t    function ByteBuffer(data) {\n\t        this.position = 0;\n\t        this.data = data;\n\t        this.int32ArrayForConvert = new Uint32Array(1);\n\t        this.int8ArrayForConvert = new Uint8Array(this.int32ArrayForConvert.buffer);\n\t    }\n\t    ByteBuffer.allocate = function (size) {\n\t        if (size === void 0) { size = 16; }\n\t        return new ByteBuffer(new Uint8Array(size));\n\t    };\n\t    ByteBuffer.prototype.put = function (value) {\n\t        if (this.position === this.data.length) {\n\t            var oldArray = this.data;\n\t            this.data = new Uint8Array(this.data.length * 2);\n\t            this.data.set(oldArray);\n\t        }\n\t        this.data[this.position] = value;\n\t        this.position++;\n\t    };\n\t    ByteBuffer.prototype.putInt32 = function (value) {\n\t        if (this.data.length - this.position < 4) {\n\t            var oldArray = this.data;\n\t            this.data = new Uint8Array(this.data.length * 2 + 4);\n\t            this.data.set(oldArray);\n\t        }\n\t        this.int32ArrayForConvert[0] = value;\n\t        this.data.set(this.int8ArrayForConvert.reverse(), this.position);\n\t        this.position += 4;\n\t    };\n\t    ByteBuffer.prototype.putInt64 = function (value) {\n\t        this.putInt32(floor(value / TWO_POW_32));\n\t        this.putInt32(value);\n\t    };\n\t    ByteBuffer.prototype.putArray = function (array) {\n\t        if (this.data.length - this.position < array.byteLength) {\n\t            var oldArray = this.data;\n\t            this.data = new Uint8Array(this.position + array.byteLength);\n\t            this.data.set(oldArray);\n\t        }\n\t        this.data.set(array, this.position);\n\t        this.position += array.byteLength;\n\t    };\n\t    ByteBuffer.prototype.get = function () {\n\t        var value = this.data[this.position];\n\t        this.position++;\n\t        return value;\n\t    };\n\t    ByteBuffer.prototype.getInt32 = function () {\n\t        this.int8ArrayForConvert.set(this.data.slice(this.position, this.position + 4).reverse());\n\t        var value = this.int32ArrayForConvert[0];\n\t        this.position += 4;\n\t        return value;\n\t    };\n\t    ByteBuffer.prototype.getInt64 = function () {\n\t        var high = this.getInt32();\n\t        var low = this.getInt32();\n\t        return high * TWO_POW_32 + low;\n\t    };\n\t    ByteBuffer.prototype.resetPosition = function () {\n\t        this.position = 0;\n\t    };\n\t    return ByteBuffer;\n\t}());\n\texports.default = ByteBuffer;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = Object.setPrototypeOf ||\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar AbstractHistogram_1 = __webpack_require__(1);\n\tvar Int32Histogram = /** @class */ (function (_super) {\n\t    __extends(Int32Histogram, _super);\n\t    function Int32Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n\t        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n\t        _this.totalCount = 0;\n\t        _this.counts = new Uint32Array(_this.countsArrayLength);\n\t        return _this;\n\t    }\n\t    Int32Histogram.prototype.clearCounts = function () {\n\t        this.counts.fill(0);\n\t    };\n\t    Int32Histogram.prototype.incrementCountAtIndex = function (index) {\n\t        var currentCount = this.counts[index];\n\t        var newCount = currentCount + 1;\n\t        if (newCount < 0) {\n\t            throw newCount + \" would overflow short integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    Int32Histogram.prototype.addToCountAtIndex = function (index, value) {\n\t        var currentCount = this.counts[index];\n\t        var newCount = currentCount + value;\n\t        if (newCount < Number.MIN_SAFE_INTEGER ||\n\t            newCount > Number.MAX_SAFE_INTEGER) {\n\t            throw newCount + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    Int32Histogram.prototype.setCountAtIndex = function (index, value) {\n\t        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n\t            throw value + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = value;\n\t    };\n\t    Int32Histogram.prototype.resize = function (newHighestTrackableValue) {\n\t        this.establishSize(newHighestTrackableValue);\n\t        var newCounts = new Uint32Array(this.countsArrayLength);\n\t        newCounts.set(this.counts);\n\t        this.counts = newCounts;\n\t    };\n\t    Int32Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n\t    Int32Histogram.prototype.incrementTotalCount = function () {\n\t        this.totalCount++;\n\t    };\n\t    Int32Histogram.prototype.addToTotalCount = function (value) {\n\t        this.totalCount += value;\n\t    };\n\t    Int32Histogram.prototype.setTotalCount = function (value) {\n\t        this.totalCount = value;\n\t    };\n\t    Int32Histogram.prototype.getTotalCount = function () {\n\t        return this.totalCount;\n\t    };\n\t    Int32Histogram.prototype.getCountAtIndex = function (index) {\n\t        return this.counts[index];\n\t    };\n\t    Int32Histogram.prototype._getEstimatedFootprintInBytes = function () {\n\t        return 512 + 4 * this.counts.length;\n\t    };\n\t    Int32Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n\t        var copy = new Int32Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n\t        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n\t        return copy;\n\t    };\n\t    return Int32Histogram;\n\t}(AbstractHistogram_1.default));\n\texports.default = Int32Histogram;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar ByteBuffer_1 = __webpack_require__(3);\n\tvar AbstractHistogram_1 = __webpack_require__(1);\n\tvar Int32Histogram_1 = __webpack_require__(4);\n\t__webpack_require__(10);\n\tvar base64 = __webpack_require__(9);\n\tvar decodeFromCompressedBase64 = function (base64String, histogramConstr, minBarForHighestTrackableValue) {\n\t    if (histogramConstr === void 0) { histogramConstr = Int32Histogram_1.default; }\n\t    if (minBarForHighestTrackableValue === void 0) { minBarForHighestTrackableValue = 0; }\n\t    var buffer = new ByteBuffer_1.default(base64.toByteArray(base64String));\n\t    return AbstractHistogram_1.AbstractHistogram.decodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue);\n\t};\n\texports.decodeFromCompressedBase64 = decodeFromCompressedBase64;\n\tvar encodeIntoBase64String = function (histogram, compressionLevel) {\n\t    var buffer = ByteBuffer_1.default.allocate();\n\t    var bufferSize = histogram.encodeIntoCompressedByteBuffer(buffer, compressionLevel);\n\t    var encodedBuffer = buffer.data.slice(0, bufferSize);\n\t    return base64.fromByteArray(encodedBuffer);\n\t};\n\texports.encodeIntoBase64String = encodeIntoBase64String;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar HistogramIterationValue_1 = __webpack_require__(13);\n\t/**\n\t * Used for iterating through histogram values.\n\t */\n\tvar AbstractHistogramIterator /* implements Iterator<HistogramIterationValue> */ = /** @class */ (function () {\n\t    function AbstractHistogramIterator() {\n\t        this.currentIterationValue = new HistogramIterationValue_1.default();\n\t    }\n\t    AbstractHistogramIterator.prototype.resetIterator = function (histogram) {\n\t        this.histogram = histogram;\n\t        this.savedHistogramTotalRawCount = histogram.getTotalCount();\n\t        this.arrayTotalCount = histogram.getTotalCount();\n\t        this.currentIndex = 0;\n\t        this.currentValueAtIndex = 0;\n\t        this.nextValueAtIndex = Math.pow(2, histogram.unitMagnitude);\n\t        this.prevValueIteratedTo = 0;\n\t        this.totalCountToPrevIndex = 0;\n\t        this.totalCountToCurrentIndex = 0;\n\t        this.totalValueToCurrentIndex = 0;\n\t        this.countAtThisValue = 0;\n\t        this.freshSubBucket = true;\n\t        this.currentIterationValue.reset();\n\t    };\n\t    /**\n\t     * Returns true if the iteration has more elements. (In other words, returns true if next would return an\n\t     * element rather than throwing an exception.)\n\t     *\n\t     * @return true if the iterator has more elements.\n\t     */\n\t    AbstractHistogramIterator.prototype.hasNext = function () {\n\t        if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\n\t            throw \"Concurrent Modification Exception\";\n\t        }\n\t        return this.totalCountToCurrentIndex < this.arrayTotalCount;\n\t    };\n\t    /**\n\t     * Returns the next element in the iteration.\n\t     *\n\t     * @return the {@link HistogramIterationValue} associated with the next element in the iteration.\n\t     */\n\t    AbstractHistogramIterator.prototype.next = function () {\n\t        // Move through the sub buckets and buckets until we hit the next reporting level:\n\t        while (!this.exhaustedSubBuckets()) {\n\t            this.countAtThisValue = this.histogram.getCountAtIndex(this.currentIndex);\n\t            if (this.freshSubBucket) {\n\t                // Don't add unless we've incremented since last bucket...\n\t                this.totalCountToCurrentIndex += this.countAtThisValue;\n\t                this.totalValueToCurrentIndex +=\n\t                    this.countAtThisValue *\n\t                        this.histogram.highestEquivalentValue(this.currentValueAtIndex);\n\t                this.freshSubBucket = false;\n\t            }\n\t            if (this.reachedIterationLevel()) {\n\t                var valueIteratedTo = this.getValueIteratedTo();\n\t                Object.assign(this.currentIterationValue, {\n\t                    valueIteratedTo: valueIteratedTo,\n\t                    valueIteratedFrom: this.prevValueIteratedTo,\n\t                    countAtValueIteratedTo: this.countAtThisValue,\n\t                    countAddedInThisIterationStep: this.totalCountToCurrentIndex - this.totalCountToPrevIndex,\n\t                    totalCountToThisValue: this.totalCountToCurrentIndex,\n\t                    totalValueToThisValue: this.totalValueToCurrentIndex,\n\t                    percentile: 100 * this.totalCountToCurrentIndex / this.arrayTotalCount,\n\t                    percentileLevelIteratedTo: this.getPercentileIteratedTo()\n\t                });\n\t                this.prevValueIteratedTo = valueIteratedTo;\n\t                this.totalCountToPrevIndex = this.totalCountToCurrentIndex;\n\t                this.incrementIterationLevel();\n\t                if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\n\t                    throw new Error(\"Concurrent Modification Exception\");\n\t                }\n\t                return this.currentIterationValue;\n\t            }\n\t            this.incrementSubBucket();\n\t        }\n\t        throw new Error(\"Index Out Of Bounds Exception\");\n\t    };\n\t    AbstractHistogramIterator.prototype.getPercentileIteratedTo = function () {\n\t        return 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\n\t    };\n\t    AbstractHistogramIterator.prototype.getPercentileIteratedFrom = function () {\n\t        return 100 * this.totalCountToPrevIndex / this.arrayTotalCount;\n\t    };\n\t    AbstractHistogramIterator.prototype.getValueIteratedTo = function () {\n\t        return this.histogram.highestEquivalentValue(this.currentValueAtIndex);\n\t    };\n\t    AbstractHistogramIterator.prototype.exhaustedSubBuckets = function () {\n\t        return this.currentIndex >= this.histogram.countsArrayLength;\n\t    };\n\t    AbstractHistogramIterator.prototype.incrementSubBucket = function () {\n\t        this.freshSubBucket = true;\n\t        this.currentIndex++;\n\t        this.currentValueAtIndex = this.histogram.valueFromIndex(this.currentIndex);\n\t        this.nextValueAtIndex = this.histogram.valueFromIndex(this.currentIndex + 1);\n\t    };\n\t    return AbstractHistogramIterator;\n\t}());\n\texports.default = AbstractHistogramIterator;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar leftPadding = function (size) {\n\t    return function (input) {\n\t        if (input.length < size) {\n\t            return \" \".repeat(size - input.length) + input;\n\t        }\n\t        return input;\n\t    };\n\t};\n\texports.integerFormatter = function (size) {\n\t    var padding = leftPadding(size);\n\t    return function (integer) { return padding(\"\" + integer); };\n\t};\n\texports.floatFormatter = function (size, fractionDigits) {\n\t    var numberFormatter = new Intl.NumberFormat(\"en-US\", {\n\t        maximumFractionDigits: fractionDigits,\n\t        minimumFractionDigits: fractionDigits,\n\t        useGrouping: false\n\t    });\n\t    var padding = leftPadding(size);\n\t    return function (float) { return padding(numberFormatter.format(float)); };\n\t};\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n\t'use strict'\n\t\n\texports.byteLength = byteLength\n\texports.toByteArray = toByteArray\n\texports.fromByteArray = fromByteArray\n\t\n\tvar lookup = []\n\tvar revLookup = []\n\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\t\n\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\tfor (var i = 0, len = code.length; i < len; ++i) {\n\t  lookup[i] = code[i]\n\t  revLookup[code.charCodeAt(i)] = i\n\t}\n\t\n\t// Support decoding URL-safe base64 strings, as Node.js does.\n\t// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\trevLookup['-'.charCodeAt(0)] = 62\n\trevLookup['_'.charCodeAt(0)] = 63\n\t\n\tfunction placeHoldersCount (b64) {\n\t  var len = b64.length\n\t  if (len % 4 > 0) {\n\t    throw new Error('Invalid string. Length must be a multiple of 4')\n\t  }\n\t\n\t  // the number of equal signs (place holders)\n\t  // if there are two placeholders, than the two characters before it\n\t  // represent one byte\n\t  // if there is only one, then the three characters before it represent 2 bytes\n\t  // this is just a cheap hack to not do indexOf twice\n\t  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\t}\n\t\n\tfunction byteLength (b64) {\n\t  // base64 is 4/3 + up to two characters of the original data\n\t  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n\t}\n\t\n\tfunction toByteArray (b64) {\n\t  var i, l, tmp, placeHolders, arr\n\t  var len = b64.length\n\t  placeHolders = placeHoldersCount(b64)\n\t\n\t  arr = new Arr((len * 3 / 4) - placeHolders)\n\t\n\t  // if there are placeholders, only get up to the last complete 4 chars\n\t  l = placeHolders > 0 ? len - 4 : len\n\t\n\t  var L = 0\n\t\n\t  for (i = 0; i < l; i += 4) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n\t    arr[L++] = (tmp >> 16) & 0xFF\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  if (placeHolders === 2) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n\t    arr[L++] = tmp & 0xFF\n\t  } else if (placeHolders === 1) {\n\t    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n\t    arr[L++] = (tmp >> 8) & 0xFF\n\t    arr[L++] = tmp & 0xFF\n\t  }\n\t\n\t  return arr\n\t}\n\t\n\tfunction tripletToBase64 (num) {\n\t  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n\t}\n\t\n\tfunction encodeChunk (uint8, start, end) {\n\t  var tmp\n\t  var output = []\n\t  for (var i = start; i < end; i += 3) {\n\t    tmp = ((uint8[i] << 16) & 0xFF0000) + ((uint8[i + 1] << 8) & 0xFF00) + (uint8[i + 2] & 0xFF)\n\t    output.push(tripletToBase64(tmp))\n\t  }\n\t  return output.join('')\n\t}\n\t\n\tfunction fromByteArray (uint8) {\n\t  var tmp\n\t  var len = uint8.length\n\t  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n\t  var output = ''\n\t  var parts = []\n\t  var maxChunkLength = 16383 // must be multiple of 3\n\t\n\t  // go through the array every three bytes, we'll deal with trailing stuff later\n\t  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n\t    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n\t  }\n\t\n\t  // pad the end with zeros, but make sure to not forget the extra bytes\n\t  if (extraBytes === 1) {\n\t    tmp = uint8[len - 1]\n\t    output += lookup[tmp >> 2]\n\t    output += lookup[(tmp << 4) & 0x3F]\n\t    output += '=='\n\t  } else if (extraBytes === 2) {\n\t    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n\t    output += lookup[tmp >> 10]\n\t    output += lookup[(tmp >> 4) & 0x3F]\n\t    output += lookup[(tmp << 2) & 0x3F]\n\t    output += '='\n\t  }\n\t\n\t  parts.push(output)\n\t\n\t  return parts.join('')\n\t}\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar ByteBuffer_1 = __webpack_require__(3);\n\tvar AbstractHistogram_1 = __webpack_require__(1);\n\tvar ZigZagEncoding_1 = __webpack_require__(21);\n\tvar max = Math.max;\n\tvar V2EncodingCookieBase = 0x1c849303;\n\tvar V2CompressedEncodingCookieBase = 0x1c849304;\n\tvar V2maxWordSizeInBytes = 9; // LEB128-64b9B + ZigZag require up to 9 bytes per word\n\tvar encodingCookie = V2EncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\n\tvar compressedEncodingCookie = V2CompressedEncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\n\tfunction fillBufferFromCountsArray(self, buffer) {\n\t    var countsLimit = self.countsArrayIndex(self.maxValue) + 1;\n\t    var srcIndex = 0;\n\t    while (srcIndex < countsLimit) {\n\t        // V2 encoding format uses a ZigZag LEB128-64b9B encoded long. Positive values are counts,\n\t        // while negative values indicate a repeat zero counts.\n\t        var count = self.getCountAtIndex(srcIndex++);\n\t        if (count < 0) {\n\t            throw new Error(\"Cannot encode histogram containing negative counts (\" +\n\t                count +\n\t                \") at index \" +\n\t                srcIndex +\n\t                \", corresponding the value range [\" +\n\t                self.lowestEquivalentValue(self.valueFromIndex(srcIndex)) +\n\t                \",\" +\n\t                self.nextNonEquivalentValue(self.valueFromIndex(srcIndex)) +\n\t                \")\");\n\t        }\n\t        // Count trailing 0s (which follow this count):\n\t        var zerosCount = 0;\n\t        if (count == 0) {\n\t            zerosCount = 1;\n\t            while (srcIndex < countsLimit && self.getCountAtIndex(srcIndex) == 0) {\n\t                zerosCount++;\n\t                srcIndex++;\n\t            }\n\t        }\n\t        if (zerosCount > 1) {\n\t            ZigZagEncoding_1.default.encode(buffer, -zerosCount);\n\t        }\n\t        else {\n\t            ZigZagEncoding_1.default.encode(buffer, count);\n\t        }\n\t    }\n\t}\n\t/**\n\t * Encode this histogram into a ByteBuffer\n\t * @param buffer The buffer to encode into\n\t * @return The number of bytes written to the buffer\n\t */\n\tfunction encodeIntoByteBuffer(buffer) {\n\t    var self = this;\n\t    var initialPosition = buffer.position;\n\t    buffer.putInt32(encodingCookie);\n\t    buffer.putInt32(0); // Placeholder for payload length in bytes.\n\t    buffer.putInt32(1);\n\t    buffer.putInt32(self.numberOfSignificantValueDigits);\n\t    buffer.putInt64(self.lowestDiscernibleValue);\n\t    buffer.putInt64(self.highestTrackableValue);\n\t    buffer.putInt64(1);\n\t    var payloadStartPosition = buffer.position;\n\t    fillBufferFromCountsArray(self, buffer);\n\t    var backupIndex = buffer.position;\n\t    buffer.position = initialPosition + 4;\n\t    buffer.putInt32(backupIndex - payloadStartPosition); // Record the payload length\n\t    buffer.position = backupIndex;\n\t    return backupIndex - initialPosition;\n\t}\n\texports.encodeIntoByteBuffer = encodeIntoByteBuffer;\n\tfunction fillCountsArrayFromSourceBuffer(self, sourceBuffer, lengthInBytes, wordSizeInBytes) {\n\t    if (wordSizeInBytes != 2 &&\n\t        wordSizeInBytes != 4 &&\n\t        wordSizeInBytes != 8 &&\n\t        wordSizeInBytes != V2maxWordSizeInBytes) {\n\t        throw new Error(\"word size must be 2, 4, 8, or V2maxWordSizeInBytes (\" +\n\t            V2maxWordSizeInBytes +\n\t            \") bytes\");\n\t    }\n\t    var dstIndex = 0;\n\t    var endPosition = sourceBuffer.position + lengthInBytes;\n\t    while (sourceBuffer.position < endPosition) {\n\t        var zerosCount = 0;\n\t        var count = ZigZagEncoding_1.default.decode(sourceBuffer);\n\t        if (count < 0) {\n\t            zerosCount = -count;\n\t            dstIndex += zerosCount; // No need to set zeros in array. Just skip them.\n\t        }\n\t        else {\n\t            self.setCountAtIndex(dstIndex++, count);\n\t        }\n\t    }\n\t    return dstIndex; // this is the destination length\n\t}\n\tfunction getCookieBase(cookie) {\n\t    return cookie & ~0xf0;\n\t}\n\tfunction getWordSizeInBytesFromCookie(cookie) {\n\t    if (getCookieBase(cookie) == V2EncodingCookieBase ||\n\t        getCookieBase(cookie) == V2CompressedEncodingCookieBase) {\n\t        return V2maxWordSizeInBytes;\n\t    }\n\t    var sizeByte = (cookie & 0xf0) >> 4;\n\t    return sizeByte & 0xe;\n\t}\n\tfunction doDecodeFromByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue) {\n\t    var cookie = buffer.getInt32();\n\t    var payloadLengthInBytes;\n\t    var numberOfSignificantValueDigits;\n\t    var lowestTrackableUnitValue;\n\t    var highestTrackableValue;\n\t    if (getCookieBase(cookie) === V2EncodingCookieBase) {\n\t        if (getWordSizeInBytesFromCookie(cookie) != V2maxWordSizeInBytes) {\n\t            throw new Error(\"The buffer does not contain a Histogram (no valid cookie found)\");\n\t        }\n\t        payloadLengthInBytes = buffer.getInt32();\n\t        buffer.getInt32(); // normalizingIndexOffset not used\n\t        numberOfSignificantValueDigits = buffer.getInt32();\n\t        lowestTrackableUnitValue = buffer.getInt64();\n\t        highestTrackableValue = buffer.getInt64();\n\t        buffer.getInt64(); // integerToDoubleValueConversionRatio not used\n\t    }\n\t    else {\n\t        throw new Error(\"The buffer does not contain a Histogram (no valid V2 encoding cookie found)\");\n\t    }\n\t    highestTrackableValue = max(highestTrackableValue, minBarForHighestTrackableValue);\n\t    var histogram = new histogramConstr(lowestTrackableUnitValue, highestTrackableValue, numberOfSignificantValueDigits);\n\t    var filledLength = fillCountsArrayFromSourceBuffer(histogram, buffer, payloadLengthInBytes, V2maxWordSizeInBytes);\n\t    histogram.establishInternalTackingValues(filledLength);\n\t    return histogram;\n\t}\n\texports.doDecodeFromByteBuffer = doDecodeFromByteBuffer;\n\tfunction doDecodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue) {\n\t    var initialTargetPosition = buffer.position;\n\t    var cookie = buffer.getInt32();\n\t    if ((cookie & ~0xf0) !== V2CompressedEncodingCookieBase) {\n\t        throw new Error(\"Encoding not supported, only V2 is supported\");\n\t    }\n\t    var lengthOfCompressedContents = buffer.getInt32();\n\t    var pako = __webpack_require__(8);\n\t    var uncompressedBuffer = pako.inflate(buffer.data.slice(initialTargetPosition + 8, initialTargetPosition + 8 + lengthOfCompressedContents));\n\t    return doDecodeFromByteBuffer(new ByteBuffer_1.default(uncompressedBuffer), histogramConstr, minBarForHighestTrackableValue);\n\t}\n\texports.doDecodeFromCompressedByteBuffer = doDecodeFromCompressedByteBuffer;\n\t/**\n\t * Encode this histogram in compressed form into a byte array\n\t * @param targetBuffer The buffer to encode into\n\t * @return The number of bytes written to the array\n\t */\n\tfunction encodeIntoCompressedByteBuffer(targetBuffer, compressionLevel) {\n\t    var self = this;\n\t    var intermediateUncompressedByteBuffer = ByteBuffer_1.default.allocate();\n\t    var uncompressedLength = self.encodeIntoByteBuffer(intermediateUncompressedByteBuffer);\n\t    targetBuffer.putInt32(compressedEncodingCookie);\n\t    var pako = __webpack_require__(8);\n\t    var compressionOptions = compressionLevel\n\t        ? { level: compressionLevel }\n\t        : {};\n\t    var compressedArray = pako.deflate(intermediateUncompressedByteBuffer.data.slice(0, uncompressedLength), compressionOptions);\n\t    targetBuffer.putInt32(compressedArray.byteLength);\n\t    targetBuffer.putArray(compressedArray);\n\t    return targetBuffer.position;\n\t}\n\texports.encodeIntoCompressedByteBuffer = encodeIntoCompressedByteBuffer;\n\tAbstractHistogram_1.AbstractHistogram.decodeFromByteBuffer = doDecodeFromByteBuffer;\n\tAbstractHistogram_1.AbstractHistogram.decodeFromCompressedByteBuffer = doDecodeFromCompressedByteBuffer;\n\tAbstractHistogram_1.AbstractHistogram.prototype.encodeIntoByteBuffer = encodeIntoByteBuffer;\n\tAbstractHistogram_1.AbstractHistogram.prototype.encodeIntoCompressedByteBuffer = encodeIntoCompressedByteBuffer;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar EncodableHistogram = /** @class */ (function () {\n\t    function EncodableHistogram() {\n\t    }\n\t    return EncodableHistogram;\n\t}());\n\texports.EncodableHistogram = EncodableHistogram;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = Object.setPrototypeOf ||\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar AbstractHistogram_1 = __webpack_require__(1);\n\tvar Float64Histogram = /** @class */ (function (_super) {\n\t    __extends(Float64Histogram, _super);\n\t    function Float64Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n\t        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n\t        _this.totalCount = 0;\n\t        _this.counts = new Float64Array(_this.countsArrayLength);\n\t        return _this;\n\t    }\n\t    Float64Histogram.prototype.clearCounts = function () {\n\t        this.counts.fill(0);\n\t    };\n\t    Float64Histogram.prototype.incrementCountAtIndex = function (index) {\n\t        var currentCount = this.counts[index];\n\t        var newCount = currentCount + 1;\n\t        if (newCount < 0) {\n\t            throw newCount + \" would overflow short integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    Float64Histogram.prototype.addToCountAtIndex = function (index, value) {\n\t        var currentCount = this.counts[index];\n\t        var newCount = currentCount + value;\n\t        if (newCount < Number.MIN_SAFE_INTEGER ||\n\t            newCount > Number.MAX_SAFE_INTEGER) {\n\t            throw newCount + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    Float64Histogram.prototype.setCountAtIndex = function (index, value) {\n\t        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n\t            throw value + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = value;\n\t    };\n\t    Float64Histogram.prototype.resize = function (newHighestTrackableValue) {\n\t        this.establishSize(newHighestTrackableValue);\n\t        var newCounts = new Float64Array(this.countsArrayLength);\n\t        newCounts.set(this.counts);\n\t        this.counts = newCounts;\n\t    };\n\t    Float64Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n\t    Float64Histogram.prototype.incrementTotalCount = function () {\n\t        this.totalCount++;\n\t    };\n\t    Float64Histogram.prototype.addToTotalCount = function (value) {\n\t        this.totalCount += value;\n\t    };\n\t    Float64Histogram.prototype.setTotalCount = function (value) {\n\t        this.totalCount = value;\n\t    };\n\t    Float64Histogram.prototype.getTotalCount = function () {\n\t        return this.totalCount;\n\t    };\n\t    Float64Histogram.prototype.getCountAtIndex = function (index) {\n\t        return this.counts[index];\n\t    };\n\t    Float64Histogram.prototype._getEstimatedFootprintInBytes = function () {\n\t        return 512 + 8 * this.counts.length;\n\t    };\n\t    Float64Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n\t        var copy = new Float64Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n\t        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n\t        return copy;\n\t    };\n\t    return Float64Histogram;\n\t}(AbstractHistogram_1.default));\n\texports.default = Float64Histogram;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/**\n\t * Represents a value point iterated through in a Histogram, with associated stats.\n\t * <ul>\n\t * <li><b><code>valueIteratedTo</code></b> :<br> The actual value level that was iterated to by the iterator</li>\n\t * <li><b><code>prevValueIteratedTo</code></b> :<br> The actual value level that was iterated from by the iterator</li>\n\t * <li><b><code>countAtValueIteratedTo</code></b> :<br> The count of recorded values in the histogram that\n\t * exactly match this [lowestEquivalentValue(valueIteratedTo)...highestEquivalentValue(valueIteratedTo)] value\n\t * range.</li>\n\t * <li><b><code>countAddedInThisIterationStep</code></b> :<br> The count of recorded values in the histogram that\n\t * were added to the totalCountToThisValue (below) as a result on this iteration step. Since multiple iteration\n\t * steps may occur with overlapping equivalent value ranges, the count may be lower than the count found at\n\t * the value (e.g. multiple linear steps or percentile levels can occur within a single equivalent value range)</li>\n\t * <li><b><code>totalCountToThisValue</code></b> :<br> The total count of all recorded values in the histogram at\n\t * values equal or smaller than valueIteratedTo.</li>\n\t * <li><b><code>totalValueToThisValue</code></b> :<br> The sum of all recorded values in the histogram at values\n\t * equal or smaller than valueIteratedTo.</li>\n\t * <li><b><code>percentile</code></b> :<br> The percentile of recorded values in the histogram at values equal\n\t * or smaller than valueIteratedTo.</li>\n\t * <li><b><code>percentileLevelIteratedTo</code></b> :<br> The percentile level that the iterator returning this\n\t * HistogramIterationValue had iterated to. Generally, percentileLevelIteratedTo will be equal to or smaller than\n\t * percentile, but the same value point can contain multiple iteration levels for some iterators. E.g. a\n\t * PercentileIterator can stop multiple times in the exact same value point (if the count at that value covers a\n\t * range of multiple percentiles in the requested percentile iteration points).</li>\n\t * </ul>\n\t */\n\tvar HistogramIterationValue = /** @class */ (function () {\n\t    function HistogramIterationValue() {\n\t        this.reset();\n\t    }\n\t    HistogramIterationValue.prototype.reset = function () {\n\t        this.valueIteratedTo = 0;\n\t        this.valueIteratedFrom = 0;\n\t        this.countAtValueIteratedTo = 0;\n\t        this.countAddedInThisIterationStep = 0;\n\t        this.totalCountToThisValue = 0;\n\t        this.totalValueToThisValue = 0;\n\t        this.percentile = 0.0;\n\t        this.percentileLevelIteratedTo = 0.0;\n\t    };\n\t    return HistogramIterationValue;\n\t}());\n\texports.default = HistogramIterationValue;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar AbstractHistogramBase_1 = __webpack_require__(2);\n\tvar encoding_1 = __webpack_require__(5);\n\tvar TAG_PREFIX = \"Tag=\";\n\tvar TAG_PREFIX_LENGTH = \"Tag=\".length;\n\t/**\n\t * A histogram log reader.\n\t * <p>\n\t * Histogram logs are used to capture full fidelity, per-time-interval\n\t * histograms of a recorded value.\n\t * <p>\n\t * For example, a histogram log can be used to capture high fidelity\n\t * reaction-time logs for some measured system or subsystem component.\n\t * Such a log would capture a full reaction time histogram for each\n\t * logged interval, and could be used to later reconstruct a full\n\t * HdrHistogram of the measured reaction time behavior for any arbitrary\n\t * time range within the log, by adding [only] the relevant interval\n\t * histograms.\n\t * <h3>Histogram log format:</h3>\n\t * A histogram log file consists of text lines. Lines beginning with\n\t * the \"#\" character are optional and treated as comments. Lines\n\t * containing the legend (starting with \"Timestamp\") are also optional\n\t * and ignored in parsing the histogram log. All other lines must\n\t * be valid interval description lines. Text fields are delimited by\n\t * commas, spaces.\n\t * <p>\n\t * A valid interval description line contains an optional Tag=tagString\n\t * text field, followed by an interval description.\n\t * <p>\n\t * A valid interval description must contain exactly four text fields:\n\t * <ul>\n\t * <li>StartTimestamp: The first field must contain a number parse-able as a Double value,\n\t * representing the start timestamp of the interval in seconds.</li>\n\t * <li>intervalLength: The second field must contain a number parse-able as a Double value,\n\t * representing the length of the interval in seconds.</li>\n\t * <li>Interval_Max: The third field must contain a number parse-able as a Double value,\n\t * which generally represents the maximum value of the interval histogram.</li>\n\t * <li>Interval_Compressed_Histogram: The fourth field must contain a text field\n\t * parse-able as a Base64 text representation of a compressed HdrHistogram.</li>\n\t * </ul>\n\t * The log file may contain an optional indication of a starting time. Starting time\n\t * is indicated using a special comments starting with \"#[StartTime: \" and followed\n\t * by a number parse-able as a double, representing the start time (in seconds)\n\t * that may be added to timestamps in the file to determine an absolute\n\t * timestamp (e.g. since the epoch) for each interval.\n\t */\n\tvar HistogramLogReader = /** @class */ (function () {\n\t    function HistogramLogReader(logContent) {\n\t        this.lines = splitLines(logContent);\n\t        this.currentLineIndex = 0;\n\t    }\n\t    /**\n\t     * Read the next interval histogram from the log. Returns a Histogram object if\n\t     * an interval line was found, or null if not.\n\t     * <p>Upon encountering any unexpected format errors in reading the next interval\n\t     * from the file, this method will return a null.\n\t     * @return a DecodedInterval, or a null if no appropriate interval found\n\t     */\n\t    HistogramLogReader.prototype.nextIntervalHistogram = function (rangeStartTimeSec, rangeEndTimeSec) {\n\t        if (rangeStartTimeSec === void 0) { rangeStartTimeSec = 0; }\n\t        if (rangeEndTimeSec === void 0) { rangeEndTimeSec = Number.MAX_VALUE; }\n\t        while (this.currentLineIndex < this.lines.length) {\n\t            var currentLine = this.lines[this.currentLineIndex];\n\t            this.currentLineIndex++;\n\t            if (currentLine.startsWith(\"#[StartTime:\")) {\n\t                this.parseStartTimeFromLine(currentLine);\n\t            }\n\t            else if (currentLine.startsWith(\"#[BaseTime:\")) {\n\t                this.parseBaseTimeFromLine(currentLine);\n\t            }\n\t            else if (currentLine.startsWith(\"#\") ||\n\t                currentLine.startsWith('\"StartTimestamp\"')) {\n\t                // skip legend & meta data for now\n\t            }\n\t            else if (currentLine.includes(\",\")) {\n\t                var tokens = currentLine.split(\",\");\n\t                var firstToken = tokens[0];\n\t                var tag = void 0;\n\t                if (firstToken.startsWith(TAG_PREFIX)) {\n\t                    tag = firstToken.substring(TAG_PREFIX_LENGTH);\n\t                    tokens.shift();\n\t                }\n\t                else {\n\t                    tag = AbstractHistogramBase_1.NO_TAG;\n\t                }\n\t                var rawLogTimeStampInSec = tokens[0], rawIntervalLengthSec = tokens[1], base64Histogram = tokens[3];\n\t                var logTimeStampInSec = Number.parseFloat(rawLogTimeStampInSec);\n\t                if (!this.baseTimeSec) {\n\t                    // No explicit base time noted. Deduce from 1st observed time (compared to start time):\n\t                    if (logTimeStampInSec < this.startTimeSec - 365 * 24 * 3600.0) {\n\t                        // Criteria Note: if log timestamp is more than a year in the past (compared to\n\t                        // StartTime), we assume that timestamps in the log are not absolute\n\t                        this.baseTimeSec = this.startTimeSec;\n\t                    }\n\t                    else {\n\t                        // Timestamps are absolute\n\t                        this.baseTimeSec = 0.0;\n\t                    }\n\t                }\n\t                if (rangeEndTimeSec < logTimeStampInSec) {\n\t                    return null;\n\t                }\n\t                if (logTimeStampInSec < rangeStartTimeSec) {\n\t                    continue;\n\t                }\n\t                var histogram = encoding_1.decodeFromCompressedBase64(base64Histogram);\n\t                histogram.startTimeStampMsec =\n\t                    (this.baseTimeSec + logTimeStampInSec) * 1000;\n\t                var intervalLengthSec = Number.parseFloat(rawIntervalLengthSec);\n\t                histogram.endTimeStampMsec =\n\t                    (this.baseTimeSec + logTimeStampInSec + intervalLengthSec) * 1000;\n\t                histogram.tag = tag;\n\t                return histogram;\n\t            }\n\t        }\n\t        return null;\n\t    };\n\t    HistogramLogReader.prototype.parseStartTimeFromLine = function (line) {\n\t        this.startTimeSec = Number.parseFloat(line.split(\" \")[1]);\n\t    };\n\t    HistogramLogReader.prototype.parseBaseTimeFromLine = function (line) {\n\t        this.baseTimeSec = Number.parseFloat(line.split(\" \")[1]);\n\t    };\n\t    return HistogramLogReader;\n\t}());\n\tvar splitLines = function (logContent) { return logContent.split(/\\r\\n|\\r|\\n/g); };\n\tvar shouldIncludeNoTag = function (lines) {\n\t    return lines.find(function (line) {\n\t        return !line.startsWith(\"#\") &&\n\t            !line.startsWith('\"') &&\n\t            !line.startsWith(TAG_PREFIX) &&\n\t            line.includes(\",\");\n\t    });\n\t};\n\texports.listTags = function (content) {\n\t    var lines = splitLines(content);\n\t    var tags = lines\n\t        .filter(function (line) { return line.includes(\",\") && line.startsWith(TAG_PREFIX); })\n\t        .map(function (line) { return line.substring(TAG_PREFIX_LENGTH, line.indexOf(\",\")); });\n\t    var tagsWithoutDuplicates = new Set(tags);\n\t    var result = Array.from(tagsWithoutDuplicates);\n\t    if (shouldIncludeNoTag(lines)) {\n\t        result.unshift(\"NO TAG\");\n\t    }\n\t    return result;\n\t};\n\texports.default = HistogramLogReader;\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar AbstractHistogramBase_1 = __webpack_require__(2);\n\tvar encoding_1 = __webpack_require__(5);\n\tvar formatters_1 = __webpack_require__(7);\n\tvar HISTOGRAM_LOG_FORMAT_VERSION = \"1.3\";\n\tvar timeFormatter = formatters_1.floatFormatter(5, 3);\n\tvar HistogramLogWriter = /** @class */ (function () {\n\t    function HistogramLogWriter(log) {\n\t        this.log = log;\n\t        /**\n\t         * Base time to subtract from supplied histogram start/end timestamps when\n\t         * logging based on histogram timestamps.\n\t         * Base time is expected to be in msec since the epoch, as histogram start/end times\n\t         * are typically stamped with absolute times in msec since the epoch.\n\t         */\n\t        this.baseTime = 0;\n\t    }\n\t    /**\n\t     * Output an interval histogram, with the given timestamp information and the [optional] tag\n\t     * associated with the histogram, using a configurable maxValueUnitRatio. (note that the\n\t     * specified timestamp information will be used, and the timestamp information in the actual\n\t     * histogram will be ignored).\n\t     * The max value reported with the interval line will be scaled by the given maxValueUnitRatio.\n\t     * @param startTimeStampSec The start timestamp to log with the interval histogram, in seconds.\n\t     * @param endTimeStampSec The end timestamp to log with the interval histogram, in seconds.\n\t     * @param histogram The interval histogram to log.\n\t     * @param maxValueUnitRatio The ratio by which to divide the histogram's max value when reporting on it.\n\t     */\n\t    HistogramLogWriter.prototype.outputIntervalHistogram = function (histogram, startTimeStampSec, endTimeStampSec, maxValueUnitRatio) {\n\t        if (startTimeStampSec === void 0) { startTimeStampSec = (histogram.startTimeStampMsec - this.baseTime) / 1000; }\n\t        if (endTimeStampSec === void 0) { endTimeStampSec = (histogram.endTimeStampMsec - this.baseTime) / 1000; }\n\t        if (maxValueUnitRatio === void 0) { maxValueUnitRatio = 1000; }\n\t        var base64 = encoding_1.encodeIntoBase64String(histogram);\n\t        var start = timeFormatter(startTimeStampSec);\n\t        var duration = timeFormatter(endTimeStampSec - startTimeStampSec);\n\t        var max = timeFormatter(histogram.maxValue / maxValueUnitRatio);\n\t        var lineContent = start + \",\" + duration + \",\" + max + \",\" + base64 + \"\\n\";\n\t        if (histogram.tag && histogram.tag !== AbstractHistogramBase_1.NO_TAG) {\n\t            this.log(\"Tag=\" + histogram.tag + \",\" + lineContent);\n\t        }\n\t        else {\n\t            this.log(lineContent);\n\t        }\n\t    };\n\t    /**\n\t     * Log a comment to the log.\n\t     * Comments will be preceded with with the '#' character.\n\t     * @param comment the comment string.\n\t     */\n\t    HistogramLogWriter.prototype.outputComment = function (comment) {\n\t        this.log(\"#\" + comment + \"\\n\");\n\t    };\n\t    /**\n\t     * Log a start time in the log.\n\t     * @param startTimeMsec time (in milliseconds) since the absolute start time (the epoch)\n\t     */\n\t    HistogramLogWriter.prototype.outputStartTime = function (startTimeMsec) {\n\t        this.outputComment(\"[StartTime: \" + formatters_1.floatFormatter(5, 3)(startTimeMsec / 1000) + \" (seconds since epoch), \" + new Date(startTimeMsec) + \"]\\n\");\n\t    };\n\t    /**\n\t     * Output a legend line to the log.\n\t     */\n\t    HistogramLogWriter.prototype.outputLegend = function () {\n\t        this.log('\"StartTimestamp\",\"Interval_Length\",\"Interval_Max\",\"Interval_Compressed_Histogram\"\\n');\n\t    };\n\t    /**\n\t     * Output a log format version to the log.\n\t     */\n\t    HistogramLogWriter.prototype.outputLogFormatVersion = function () {\n\t        this.outputComment(\"[Histogram log format version \" + HISTOGRAM_LOG_FORMAT_VERSION + \"]\");\n\t    };\n\t    return HistogramLogWriter;\n\t}());\n\texports.default = HistogramLogWriter;\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = Object.setPrototypeOf ||\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar AbstractHistogram_1 = __webpack_require__(1);\n\tvar Int16Histogram = /** @class */ (function (_super) {\n\t    __extends(Int16Histogram, _super);\n\t    function Int16Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n\t        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n\t        _this.totalCount = 0;\n\t        _this.counts = new Uint16Array(_this.countsArrayLength);\n\t        return _this;\n\t    }\n\t    Int16Histogram.prototype.clearCounts = function () {\n\t        this.counts.fill(0);\n\t    };\n\t    Int16Histogram.prototype.incrementCountAtIndex = function (index) {\n\t        var currentCount = this.counts[index];\n\t        var newCount = currentCount + 1;\n\t        if (newCount < 0) {\n\t            throw newCount + \" would overflow short integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    Int16Histogram.prototype.addToCountAtIndex = function (index, value) {\n\t        var currentCount = this.counts[index];\n\t        var newCount = currentCount + value;\n\t        if (newCount < Number.MIN_SAFE_INTEGER ||\n\t            newCount > Number.MAX_SAFE_INTEGER) {\n\t            throw newCount + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    Int16Histogram.prototype.setCountAtIndex = function (index, value) {\n\t        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n\t            throw value + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = value;\n\t    };\n\t    Int16Histogram.prototype.resize = function (newHighestTrackableValue) {\n\t        this.establishSize(newHighestTrackableValue);\n\t        var newCounts = new Uint16Array(this.countsArrayLength);\n\t        newCounts.set(this.counts);\n\t        this.counts = newCounts;\n\t    };\n\t    Int16Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n\t    Int16Histogram.prototype.incrementTotalCount = function () {\n\t        this.totalCount++;\n\t    };\n\t    Int16Histogram.prototype.addToTotalCount = function (value) {\n\t        this.totalCount += value;\n\t    };\n\t    Int16Histogram.prototype.setTotalCount = function (value) {\n\t        this.totalCount = value;\n\t    };\n\t    Int16Histogram.prototype.getTotalCount = function () {\n\t        return this.totalCount;\n\t    };\n\t    Int16Histogram.prototype.getCountAtIndex = function (index) {\n\t        return this.counts[index];\n\t    };\n\t    Int16Histogram.prototype._getEstimatedFootprintInBytes = function () {\n\t        return 512 + 2 * this.counts.length;\n\t    };\n\t    Int16Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n\t        var copy = new Int16Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n\t        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n\t        return copy;\n\t    };\n\t    return Int16Histogram;\n\t}(AbstractHistogram_1.default));\n\texports.default = Int16Histogram;\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = Object.setPrototypeOf ||\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar AbstractHistogram_1 = __webpack_require__(1);\n\tvar Int8Histogram = /** @class */ (function (_super) {\n\t    __extends(Int8Histogram, _super);\n\t    function Int8Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n\t        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n\t        _this.totalCount = 0;\n\t        _this.counts = new Uint8Array(_this.countsArrayLength);\n\t        return _this;\n\t    }\n\t    Int8Histogram.prototype.clearCounts = function () {\n\t        this.counts.fill(0);\n\t    };\n\t    Int8Histogram.prototype.incrementCountAtIndex = function (index) {\n\t        var currentCount = this.counts[index];\n\t        var newCount = currentCount + 1;\n\t        if (newCount < 0) {\n\t            throw newCount + \" would overflow short integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    Int8Histogram.prototype.addToCountAtIndex = function (index, value) {\n\t        var currentCount = this.counts[index];\n\t        var newCount = currentCount + value;\n\t        if (newCount < Number.MIN_SAFE_INTEGER ||\n\t            newCount > Number.MAX_SAFE_INTEGER) {\n\t            throw newCount + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = newCount;\n\t    };\n\t    Int8Histogram.prototype.setCountAtIndex = function (index, value) {\n\t        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n\t            throw value + \" would overflow integer count\";\n\t        }\n\t        this.counts[index] = value;\n\t    };\n\t    Int8Histogram.prototype.resize = function (newHighestTrackableValue) {\n\t        this.establishSize(newHighestTrackableValue);\n\t        var newCounts = new Uint8Array(this.countsArrayLength);\n\t        newCounts.set(this.counts);\n\t        this.counts = newCounts;\n\t    };\n\t    Int8Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n\t    Int8Histogram.prototype.incrementTotalCount = function () {\n\t        this.totalCount++;\n\t    };\n\t    Int8Histogram.prototype.addToTotalCount = function (value) {\n\t        this.totalCount += value;\n\t    };\n\t    Int8Histogram.prototype.setTotalCount = function (value) {\n\t        this.totalCount = value;\n\t    };\n\t    Int8Histogram.prototype.getTotalCount = function () {\n\t        return this.totalCount;\n\t    };\n\t    Int8Histogram.prototype.getCountAtIndex = function (index) {\n\t        return this.counts[index];\n\t    };\n\t    Int8Histogram.prototype._getEstimatedFootprintInBytes = function () {\n\t        return 512 + this.counts.length;\n\t    };\n\t    Int8Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n\t        var copy = new Int8Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n\t        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n\t        return copy;\n\t    };\n\t    return Int8Histogram;\n\t}(AbstractHistogram_1.default));\n\texports.default = Int8Histogram;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = Object.setPrototypeOf ||\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar AbstractHistogramIterator_1 = __webpack_require__(6);\n\tvar pow = Math.pow, floor = Math.floor, log2 = Math.log2;\n\t/**\n\t * Used for iterating through histogram values according to percentile levels. The iteration is\n\t * performed in steps that start at 0% and reduce their distance to 100% according to the\n\t * <i>percentileTicksPerHalfDistance</i> parameter, ultimately reaching 100% when all recorded histogram\n\t * values are exhausted.\n\t */\n\tvar PercentileIterator = /** @class */ (function (_super) {\n\t    __extends(PercentileIterator, _super);\n\t    /**\n\t     * @param histogram The histogram this iterator will operate on\n\t     * @param percentileTicksPerHalfDistance The number of equal-sized iteration steps per half-distance to 100%.\n\t     */\n\t    function PercentileIterator(histogram, percentileTicksPerHalfDistance) {\n\t        var _this = _super.call(this) || this;\n\t        _this.percentileTicksPerHalfDistance = 0;\n\t        _this.percentileLevelToIterateTo = 0;\n\t        _this.percentileLevelToIterateFrom = 0;\n\t        _this.reachedLastRecordedValue = false;\n\t        _this.doReset(histogram, percentileTicksPerHalfDistance);\n\t        return _this;\n\t    }\n\t    /**\n\t     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\n\t     *\n\t     * @param percentileTicksPerHalfDistance The number of iteration steps per half-distance to 100%.\n\t     */\n\t    PercentileIterator.prototype.reset = function (percentileTicksPerHalfDistance) {\n\t        this.doReset(this.histogram, percentileTicksPerHalfDistance);\n\t    };\n\t    PercentileIterator.prototype.doReset = function (histogram, percentileTicksPerHalfDistance) {\n\t        _super.prototype.resetIterator.call(this, histogram);\n\t        this.percentileTicksPerHalfDistance = percentileTicksPerHalfDistance;\n\t        this.percentileLevelToIterateTo = 0;\n\t        this.percentileLevelToIterateFrom = 0;\n\t        this.reachedLastRecordedValue = false;\n\t    };\n\t    PercentileIterator.prototype.hasNext = function () {\n\t        if (_super.prototype.hasNext.call(this))\n\t            return true;\n\t        if (!this.reachedLastRecordedValue && this.arrayTotalCount > 0) {\n\t            this.percentileLevelToIterateTo = 100;\n\t            this.reachedLastRecordedValue = true;\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\t    PercentileIterator.prototype.incrementIterationLevel = function () {\n\t        this.percentileLevelToIterateFrom = this.percentileLevelToIterateTo;\n\t        // The choice to maintain fixed-sized \"ticks\" in each half-distance to 100% [starting\n\t        // from 0%], as opposed to a \"tick\" size that varies with each interval, was made to\n\t        // make the steps easily comprehensible and readable to humans. The resulting percentile\n\t        // steps are much easier to browse through in a percentile distribution output, for example.\n\t        //\n\t        // We calculate the number of equal-sized \"ticks\" that the 0-100 range will be divided\n\t        // by at the current scale. The scale is detemined by the percentile level we are\n\t        // iterating to. The following math determines the tick size for the current scale,\n\t        // and maintain a fixed tick size for the remaining \"half the distance to 100%\"\n\t        // [from either 0% or from the previous half-distance]. When that half-distance is\n\t        // crossed, the scale changes and the tick size is effectively cut in half.\n\t        // percentileTicksPerHalfDistance = 5\n\t        // percentileReportingTicks = 10,\n\t        var percentileReportingTicks = this.percentileTicksPerHalfDistance *\n\t            pow(2, floor(log2(100 / (100 - this.percentileLevelToIterateTo))) + 1);\n\t        this.percentileLevelToIterateTo += 100 / percentileReportingTicks;\n\t    };\n\t    PercentileIterator.prototype.reachedIterationLevel = function () {\n\t        if (this.countAtThisValue === 0) {\n\t            return false;\n\t        }\n\t        var currentPercentile = 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\n\t        return currentPercentile >= this.percentileLevelToIterateTo;\n\t    };\n\t    PercentileIterator.prototype.getPercentileIteratedTo = function () {\n\t        return this.percentileLevelToIterateTo;\n\t    };\n\t    PercentileIterator.prototype.getPercentileIteratedFrom = function () {\n\t        return this.percentileLevelToIterateFrom;\n\t    };\n\t    return PercentileIterator;\n\t}(AbstractHistogramIterator_1.default));\n\texports.default = PercentileIterator;\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar __extends = (this && this.__extends) || (function () {\n\t    var extendStatics = Object.setPrototypeOf ||\n\t        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar AbstractHistogramIterator_1 = __webpack_require__(6);\n\t/**\n\t * Used for iterating through all recorded histogram values using the finest granularity steps supported by the\n\t * underlying representation. The iteration steps through all non-zero recorded value counts, and terminates when\n\t * all recorded histogram values are exhausted.\n\t */\n\tvar RecordedValuesIterator = /** @class */ (function (_super) {\n\t    __extends(RecordedValuesIterator, _super);\n\t    /**\n\t     * @param histogram The histogram this iterator will operate on\n\t     */\n\t    function RecordedValuesIterator(histogram) {\n\t        var _this = _super.call(this) || this;\n\t        _this.doReset(histogram);\n\t        return _this;\n\t    }\n\t    /**\n\t     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\n\t     */\n\t    RecordedValuesIterator.prototype.reset = function () {\n\t        this.doReset(this.histogram);\n\t    };\n\t    RecordedValuesIterator.prototype.doReset = function (histogram) {\n\t        _super.prototype.resetIterator.call(this, histogram);\n\t        this.visitedIndex = -1;\n\t    };\n\t    RecordedValuesIterator.prototype.incrementIterationLevel = function () {\n\t        this.visitedIndex = this.currentIndex;\n\t    };\n\t    RecordedValuesIterator.prototype.reachedIterationLevel = function () {\n\t        var currentCount = this.histogram.getCountAtIndex(this.currentIndex);\n\t        return currentCount != 0 && this.visitedIndex !== this.currentIndex;\n\t    };\n\t    return RecordedValuesIterator;\n\t}(AbstractHistogramIterator_1.default));\n\texports.default = RecordedValuesIterator;\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar Int32Histogram_1 = __webpack_require__(4);\n\t/**\n\t * Records integer values, and provides stable interval {@link Histogram} samples from\n\t * live recorded data without interrupting or stalling active recording of values. Each interval\n\t * histogram provided contains all value counts accumulated since the previous interval histogram\n\t * was taken.\n\t * <p>\n\t * This pattern is commonly used in logging interval histogram information while recording is ongoing.\n\t * <p>\n\t * {@link Recorder} supports concurrent\n\t * {@link Recorder#recordValue} or\n\t * {@link Recorder#recordValueWithExpectedInterval} calls.\n\t *\n\t */\n\tvar Recorder = /** @class */ (function () {\n\t    /**\n\t     * Construct an auto-resizing {@link Recorder} with a lowest discernible value of\n\t     * 1 and an auto-adjusting highestTrackableValue. Can auto-resize up to track values up to Number.MAX_SAFE_INTEGER.\n\t     *\n\t     * @param numberOfSignificantValueDigits Specifies the precision to use. This is the number of significant\n\t     *                                       decimal digits to which the histogram will maintain value resolution\n\t     *                                       and separation. Must be a non-negative integer between 0 and 5.\n\t     * @param clock (for testing purpose) an action that give current time in ms since 1970\n\t     */\n\t    function Recorder(numberOfSignificantValueDigits, clock) {\n\t        if (numberOfSignificantValueDigits === void 0) { numberOfSignificantValueDigits = 3; }\n\t        if (clock === void 0) { clock = function () { return new Date().getTime(); }; }\n\t        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\n\t        this.clock = clock;\n\t        this.activeHistogram = new Int32Histogram_1.default(1, Number.MAX_SAFE_INTEGER, numberOfSignificantValueDigits);\n\t        Recorder.idGenerator++;\n\t        this.activeHistogram.containingInstanceId = Recorder.idGenerator;\n\t        this.activeHistogram.startTimeStampMsec = clock();\n\t    }\n\t    /**\n\t     * Record a value in the histogram\n\t     *\n\t     * @param value The value to be recorded\n\t     * @throws may throw Error if value is exceeds highestTrackableValue\n\t     */\n\t    Recorder.prototype.recordValue = function (value) {\n\t        this.activeHistogram.recordValue(value);\n\t    };\n\t    /**\n\t     * Record a value in the histogram (adding to the value's current count)\n\t     *\n\t     * @param value The value to be recorded\n\t     * @param count The number of occurrences of this value to record\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n\t     */\n\t    Recorder.prototype.recordValueWithCount = function (value, count) {\n\t        this.activeHistogram.recordValueWithCount(value, count);\n\t    };\n\t    /**\n\t     * Record a value\n\t     * <p>\n\t     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n\t     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\n\t     * (down to the expectedIntervalBetweenValueSamples) value records.\n\t     * <p>\n\t     * See related notes {@link AbstractHistogram#recordValueWithExpectedInterval(long, long)}\n\t     * for more explanations about coordinated omission and expected interval correction.\n\t     *      *\n\t     * @param value The value to record\n\t     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n\t     *                                           auto-generated value records as appropriate if value is larger\n\t     *                                           than expectedIntervalBetweenValueSamples\n\t     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n\t     */\n\t    Recorder.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n\t        this.activeHistogram.recordValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\n\t    };\n\t    /**\n\t     * Get an interval histogram, which will include a stable, consistent view of all value counts\n\t     * accumulated since the last interval histogram was taken.\n\t     * <p>\n\t     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n\t     * getIntervalHistogram(histogramToRecycle)}\n\t     * accepts a previously returned interval histogram that can be recycled internally to avoid allocation\n\t     * and content copying operations, and is therefore significantly more efficient for repeated use than\n\t     * {@link Recorder#getIntervalHistogram()} and\n\t     * {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()}. The provided\n\t     * {@code histogramToRecycle} must\n\t     * be either be null or an interval histogram returned by a previous call to\n\t     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n\t     * getIntervalHistogram(histogramToRecycle)} or\n\t     * {@link Recorder#getIntervalHistogram()}.\n\t     * <p>\n\t     * NOTE: The caller is responsible for not recycling the same returned interval histogram more than once. If\n\t     * the same interval histogram instance is recycled more than once, behavior is undefined.\n\t     * <p>\n\t     * Calling {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n\t     * getIntervalHistogram(histogramToRecycle)} will reset the value counts, and start accumulating value\n\t     * counts for the next interval\n\t     *\n\t     * @param histogramToRecycle a previously returned interval histogram that may be recycled to avoid allocation and\n\t     *                           copy operations.\n\t     * @return a histogram containing the value counts accumulated since the last interval histogram was taken.\n\t     */\n\t    Recorder.prototype.getIntervalHistogram = function (histogramToRecycle) {\n\t        if (histogramToRecycle) {\n\t            var histogramToRecycleWithId = histogramToRecycle;\n\t            if (histogramToRecycleWithId.containingInstanceId !==\n\t                this.activeHistogram.containingInstanceId) {\n\t                throw \"replacement histogram must have been obtained via a previous getIntervalHistogram() call from this Recorder\";\n\t            }\n\t        }\n\t        this.inactiveHistogram = histogramToRecycle;\n\t        this.performIntervalSample();\n\t        var sampledHistogram = this.inactiveHistogram;\n\t        this.inactiveHistogram = null; // Once we expose the sample, we can't reuse it internally until it is recycled\n\t        return sampledHistogram;\n\t    };\n\t    /**\n\t     * Place a copy of the value counts accumulated since accumulated (since the last interval histogram\n\t     * was taken) into {@code targetHistogram}.\n\t     *\n\t     * Calling {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()} will reset\n\t     * the value counts, and start accumulating value counts for the next interval.\n\t     *\n\t     * @param targetHistogram the histogram into which the interval histogram's data should be copied\n\t     */\n\t    Recorder.prototype.getIntervalHistogramInto = function (targetHistogram) {\n\t        this.performIntervalSample();\n\t        if (this.inactiveHistogram) {\n\t            targetHistogram.add(this.inactiveHistogram);\n\t            targetHistogram.startTimeStampMsec = this.inactiveHistogram.startTimeStampMsec;\n\t            targetHistogram.endTimeStampMsec = this.inactiveHistogram.endTimeStampMsec;\n\t        }\n\t    };\n\t    /**\n\t     * Reset any value counts accumulated thus far.\n\t     */\n\t    Recorder.prototype.reset = function () {\n\t        this.activeHistogram.reset();\n\t        this.activeHistogram.startTimeStampMsec = this.clock();\n\t    };\n\t    Recorder.prototype.performIntervalSample = function () {\n\t        if (!this.inactiveHistogram) {\n\t            this.inactiveHistogram = new Int32Histogram_1.default(1, Number.MAX_SAFE_INTEGER, this.numberOfSignificantValueDigits);\n\t            this.inactiveHistogram.containingInstanceId = this.activeHistogram.containingInstanceId;\n\t        }\n\t        this.inactiveHistogram.reset();\n\t        var tempHistogram = this.activeHistogram;\n\t        this.activeHistogram = this.inactiveHistogram;\n\t        this.inactiveHistogram = tempHistogram;\n\t        var currentTimeInMs = this.clock();\n\t        this.inactiveHistogram.endTimeStampMsec = currentTimeInMs;\n\t        this.activeHistogram.startTimeStampMsec = currentTimeInMs;\n\t    };\n\t    Recorder.idGenerator = 0;\n\t    return Recorder;\n\t}());\n\texports.default = Recorder;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar pow = Math.pow, floor = Math.floor;\n\tvar TWO_POW_7 = pow(2, 7);\n\tvar TWO_POW_14 = pow(2, 14);\n\tvar TWO_POW_21 = pow(2, 21);\n\tvar TWO_POW_28 = pow(2, 28);\n\tvar TWO_POW_35 = pow(2, 35);\n\tvar TWO_POW_42 = pow(2, 42);\n\tvar TWO_POW_49 = pow(2, 49);\n\tvar TWO_POW_56 = pow(2, 56);\n\t/**\n\t * This class provides encoding and decoding methods for writing and reading\n\t * ZigZag-encoded LEB128-64b9B-variant (Little Endian Base 128) values to/from a\n\t * {@link ByteBuffer}. LEB128's variable length encoding provides for using a\n\t * smaller nuber of bytes for smaller values, and the use of ZigZag encoding\n\t * allows small (closer to zero) negative values to use fewer bytes. Details\n\t * on both LEB128 and ZigZag can be readily found elsewhere.\n\t *\n\t * The LEB128-64b9B-variant encoding used here diverges from the \"original\"\n\t * LEB128 as it extends to 64 bit values: In the original LEB128, a 64 bit\n\t * value can take up to 10 bytes in the stream, where this variant's encoding\n\t * of a 64 bit values will max out at 9 bytes.\n\t *\n\t * As such, this encoder/decoder should NOT be used for encoding or decoding\n\t * \"standard\" LEB128 formats (e.g. Google Protocol Buffers).\n\t */\n\tvar ZigZagEncoding = /** @class */ (function () {\n\t    function ZigZagEncoding() {\n\t    }\n\t    /**\n\t     * Writes a long value to the given buffer in LEB128 ZigZag encoded format\n\t     * (negative numbers not supported)\n\t     * @param buffer the buffer to write to\n\t     * @param value  the value to write to the buffer\n\t     */\n\t    ZigZagEncoding.encode = function (buffer, value) {\n\t        if (value >= 0) {\n\t            value = value * 2;\n\t        }\n\t        else {\n\t            value = -value * 2 - 1;\n\t        }\n\t        if (value < TWO_POW_7) {\n\t            buffer.put(value);\n\t        }\n\t        else {\n\t            buffer.put(value | 0x80);\n\t            if (value < TWO_POW_14) {\n\t                buffer.put(floor(value / TWO_POW_7));\n\t            }\n\t            else {\n\t                buffer.put(floor(value / TWO_POW_7) | 0x80);\n\t                if (value < TWO_POW_21) {\n\t                    buffer.put(floor(value / TWO_POW_14));\n\t                }\n\t                else {\n\t                    buffer.put(floor(value / TWO_POW_14) | 0x80);\n\t                    if (value < TWO_POW_28) {\n\t                        buffer.put(floor(value / TWO_POW_21));\n\t                    }\n\t                    else {\n\t                        buffer.put(floor(value / TWO_POW_21) | 0x80);\n\t                        if (value < TWO_POW_35) {\n\t                            buffer.put(floor(value / TWO_POW_28));\n\t                        }\n\t                        else {\n\t                            buffer.put(floor(value / TWO_POW_28) | 0x80);\n\t                            if (value < TWO_POW_42) {\n\t                                buffer.put(floor(value / TWO_POW_35));\n\t                            }\n\t                            else {\n\t                                buffer.put(floor(value / TWO_POW_35) | 0x80);\n\t                                if (value < TWO_POW_49) {\n\t                                    buffer.put(floor(value / TWO_POW_42));\n\t                                }\n\t                                else {\n\t                                    buffer.put(floor(value / TWO_POW_42) | 0x80);\n\t                                    if (value < TWO_POW_56) {\n\t                                        buffer.put(floor(value / TWO_POW_49));\n\t                                    }\n\t                                    else {\n\t                                        // should not happen\n\t                                        buffer.put(floor(value / TWO_POW_49) + 0x80);\n\t                                        buffer.put(floor(value / TWO_POW_56));\n\t                                    }\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t    /**\n\t     * Read an LEB128-64b9B ZigZag encoded long value from the given buffer\n\t     * (negative numbers not supported)\n\t     * @param buffer the buffer to read from\n\t     * @return the value read from the buffer\n\t     */\n\t    ZigZagEncoding.decode = function (buffer) {\n\t        var v = buffer.get();\n\t        var value = v & 0x7f;\n\t        if ((v & 0x80) != 0) {\n\t            v = buffer.get();\n\t            value += (v & 0x7f) * TWO_POW_7;\n\t            if ((v & 0x80) != 0) {\n\t                v = buffer.get();\n\t                value += (v & 0x7f) * TWO_POW_14;\n\t                if ((v & 0x80) != 0) {\n\t                    v = buffer.get();\n\t                    value += (v & 0x7f) * TWO_POW_21;\n\t                    if ((v & 0x80) != 0) {\n\t                        v = buffer.get();\n\t                        value += (v & 0x7f) * TWO_POW_28;\n\t                        if ((v & 0x80) != 0) {\n\t                            v = buffer.get();\n\t                            value += (v & 0x7f) * TWO_POW_35;\n\t                            if ((v & 0x80) != 0) {\n\t                                v = buffer.get();\n\t                                value += (v & 0x7f) * TWO_POW_42;\n\t                                if ((v & 0x80) != 0) {\n\t                                    v = buffer.get();\n\t                                    value += (v & 0x7f) * TWO_POW_49;\n\t                                    if ((v & 0x80) != 0) {\n\t                                        v = buffer.get();\n\t                                        value += (v & 0x7f) * TWO_POW_56;\n\t                                    }\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (value % 2 === 0) {\n\t            value = value / 2;\n\t        }\n\t        else {\n\t            value = -(value + 1) / 2;\n\t        }\n\t        return value;\n\t    };\n\t    return ZigZagEncoding;\n\t}());\n\texports.default = ZigZagEncoding;\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tvar ByteBuffer_1 = __webpack_require__(3);\n\texports.ByteBuffer = ByteBuffer_1.default;\n\tvar Int8Histogram_1 = __webpack_require__(17);\n\texports.Int8Histogram = Int8Histogram_1.default;\n\tvar Int16Histogram_1 = __webpack_require__(16);\n\texports.Int16Histogram = Int16Histogram_1.default;\n\tvar Int32Histogram_1 = __webpack_require__(4);\n\texports.Int32Histogram = Int32Histogram_1.default;\n\tvar Float64Histogram_1 = __webpack_require__(12);\n\texports.Float64Histogram = Float64Histogram_1.default;\n\tvar AbstractHistogram_1 = __webpack_require__(1);\n\texports.AbstractHistogram = AbstractHistogram_1.default;\n\texports.Histogram = AbstractHistogram_1.default;\n\tvar HistogramLogReader_1 = __webpack_require__(14);\n\texports.HistogramLogReader = HistogramLogReader_1.default;\n\texports.listTags = HistogramLogReader_1.listTags;\n\tvar HistogramLogWriter_1 = __webpack_require__(15);\n\texports.HistogramLogWriter = HistogramLogWriter_1.default;\n\tvar encoding_1 = __webpack_require__(5);\n\texports.decodeFromCompressedBase64 = encoding_1.decodeFromCompressedBase64;\n\texports.encodeIntoBase64String = encoding_1.encodeIntoBase64String;\n\tvar Recorder_1 = __webpack_require__(20);\n\texports.Recorder = Recorder_1.default;\n\tvar defaultRequest = {\n\t    bitBucketSize: 32,\n\t    autoResize: true,\n\t    lowestDiscernibleValue: 1,\n\t    highestTrackableValue: 2,\n\t    numberOfSignificantValueDigits: 3\n\t};\n\texports.defaultRequest = defaultRequest;\n\tvar build = function (request) {\n\t    if (request === void 0) { request = defaultRequest; }\n\t    var parameters = Object.assign({}, defaultRequest, request);\n\t    var histogramConstr;\n\t    switch (parameters.bitBucketSize) {\n\t        case 8:\n\t            histogramConstr = Int8Histogram_1.default;\n\t            break;\n\t        case 16:\n\t            histogramConstr = Int16Histogram_1.default;\n\t            break;\n\t        case 32:\n\t            histogramConstr = Int32Histogram_1.default;\n\t            break;\n\t        default:\n\t            histogramConstr = Float64Histogram_1.default;\n\t    }\n\t    var histogram = new histogramConstr(parameters.lowestDiscernibleValue, parameters.highestTrackableValue, parameters.numberOfSignificantValueDigits);\n\t    histogram.autoResize = parameters.autoResize;\n\t    return histogram;\n\t};\n\texports.build = build;\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t/*\n\t * This is a TypeScript port of the original Java version, which was written by\n\t * Gil Tene as described in\n\t * https://github.com/HdrHistogram/HdrHistogram\n\t * and released to the public domain, as explained at\n\t * http://creativecommons.org/publicdomain/zero/1.0/\n\t */\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tvar ulp = function (x) { return Math.pow(2, Math.floor(Math.log2(x)) - 52); };\n\texports.default = ulp;\n\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// hdrhistogram.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a8fef650f1e23151832d","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\nvar RecordedValuesIterator_1 = require(\"./RecordedValuesIterator\");\nvar PercentileIterator_1 = require(\"./PercentileIterator\");\nvar formatters_1 = require(\"./formatters\");\nvar ulp_1 = require(\"./ulp\");\nvar pow = Math.pow, floor = Math.floor, ceil = Math.ceil, log2 = Math.log2, max = Math.max, min = Math.min;\nvar AbstractHistogram = /** @class */ (function (_super) {\n    __extends(AbstractHistogram, _super);\n    function AbstractHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this) || this;\n        _this.maxValue = 0;\n        _this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\n        // Verify argument validity\n        if (lowestDiscernibleValue < 1) {\n            throw new Error(\"lowestDiscernibleValue must be >= 1\");\n        }\n        if (highestTrackableValue < 2 * lowestDiscernibleValue) {\n            throw new Error(\"highestTrackableValue must be >= 2 * lowestDiscernibleValue\");\n        }\n        if (numberOfSignificantValueDigits < 0 ||\n            numberOfSignificantValueDigits > 5) {\n            throw new Error(\"numberOfSignificantValueDigits must be between 0 and 5\");\n        }\n        _this.identity = AbstractHistogramBase_1.AbstractHistogramBase.identityBuilder++;\n        _this.init(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, 1.0, 0);\n        return _this;\n    }\n    AbstractHistogram.prototype.updatedMaxValue = function (value) {\n        var internalValue = value + this.unitMagnitudeMask;\n        this.maxValue = internalValue;\n    };\n    AbstractHistogram.prototype.updateMinNonZeroValue = function (value) {\n        if (value <= this.unitMagnitudeMask) {\n            return;\n        }\n        var internalValue = floor(value / this.lowestDiscernibleValueRounded) *\n            this.lowestDiscernibleValueRounded;\n        this.minNonZeroValue = internalValue;\n    };\n    AbstractHistogram.prototype.resetMinNonZeroValue = function (minNonZeroValue) {\n        var internalValue = floor(minNonZeroValue / this.lowestDiscernibleValueRounded) *\n            this.lowestDiscernibleValueRounded;\n        this.minNonZeroValue =\n            minNonZeroValue === Number.MAX_SAFE_INTEGER\n                ? minNonZeroValue\n                : internalValue;\n    };\n    AbstractHistogram.prototype.init = function (lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, integerToDoubleValueConversionRatio, normalizingIndexOffset) {\n        this.lowestDiscernibleValue = lowestDiscernibleValue;\n        this.highestTrackableValue = highestTrackableValue;\n        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\n        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\n        if (normalizingIndexOffset !== 0) {\n            this.setNormalizingIndexOffset(normalizingIndexOffset);\n        }\n        /*\n        * Given a 3 decimal point accuracy, the expectation is obviously for \"+/- 1 unit at 1000\". It also means that\n        * it's \"ok to be +/- 2 units at 2000\". The \"tricky\" thing is that it is NOT ok to be +/- 2 units at 1999. Only\n        * starting at 2000. So internally, we need to maintain single unit resolution to 2x 10^decimalPoints.\n        */\n        var largestValueWithSingleUnitResolution = 2 * floor(pow(10, numberOfSignificantValueDigits));\n        this.unitMagnitude = floor(log2(lowestDiscernibleValue));\n        this.lowestDiscernibleValueRounded = pow(2, this.unitMagnitude);\n        this.unitMagnitudeMask = this.lowestDiscernibleValueRounded - 1;\n        // We need to maintain power-of-two subBucketCount (for clean direct indexing) that is large enough to\n        // provide unit resolution to at least largestValueWithSingleUnitResolution. So figure out\n        // largestValueWithSingleUnitResolution's nearest power-of-two (rounded up), and use that:\n        var subBucketCountMagnitude = ceil(log2(largestValueWithSingleUnitResolution));\n        this.subBucketHalfCountMagnitude =\n            (subBucketCountMagnitude > 1 ? subBucketCountMagnitude : 1) - 1;\n        this.subBucketCount = pow(2, this.subBucketHalfCountMagnitude + 1);\n        this.subBucketHalfCount = this.subBucketCount / 2;\n        this.subBucketMask =\n            (floor(this.subBucketCount) - 1) * pow(2, this.unitMagnitude);\n        this.establishSize(highestTrackableValue);\n        this.leadingZeroCountBase =\n            53 - this.unitMagnitude - this.subBucketHalfCountMagnitude - 1;\n        this.percentileIterator = new PercentileIterator_1.default(this, 1);\n        this.recordedValuesIterator = new RecordedValuesIterator_1.default(this);\n    };\n    /**\n     * The buckets (each of which has subBucketCount sub-buckets, here assumed to be 2048 as an example) overlap:\n     *\n     * <pre>\n     * The 0'th bucket covers from 0...2047 in multiples of 1, using all 2048 sub-buckets\n     * The 1'th bucket covers from 2048..4097 in multiples of 2, using only the top 1024 sub-buckets\n     * The 2'th bucket covers from 4096..8191 in multiple of 4, using only the top 1024 sub-buckets\n     * ...\n     * </pre>\n     *\n     * Bucket 0 is \"special\" here. It is the only one that has 2048 entries. All the rest have 1024 entries (because\n     * their bottom half overlaps with and is already covered by the all of the previous buckets put together). In other\n     * words, the k'th bucket could represent 0 * 2^k to 2048 * 2^k in 2048 buckets with 2^k precision, but the midpoint\n     * of 1024 * 2^k = 2048 * 2^(k-1) = the k-1'th bucket's end, so we would use the previous bucket for those lower\n     * values as it has better precision.\n     */\n    AbstractHistogram.prototype.establishSize = function (newHighestTrackableValue) {\n        // establish counts array length:\n        this.countsArrayLength = this.determineArrayLengthNeeded(newHighestTrackableValue);\n        // establish exponent range needed to support the trackable value with no overflow:\n        this.bucketCount = this.getBucketsNeededToCoverValue(newHighestTrackableValue);\n        // establish the new highest trackable value:\n        this.highestTrackableValue = newHighestTrackableValue;\n    };\n    AbstractHistogram.prototype.determineArrayLengthNeeded = function (highestTrackableValue) {\n        if (highestTrackableValue < 2 * this.lowestDiscernibleValue) {\n            throw new Error(\"highestTrackableValue (\" +\n                highestTrackableValue +\n                \") cannot be < (2 * lowestDiscernibleValue)\");\n        }\n        //determine counts array length needed:\n        var countsArrayLength = this.getLengthForNumberOfBuckets(this.getBucketsNeededToCoverValue(highestTrackableValue));\n        return countsArrayLength;\n    };\n    /**\n     * If we have N such that subBucketCount * 2^N > max value, we need storage for N+1 buckets, each with enough\n     * slots to hold the top half of the subBucketCount (the lower half is covered by previous buckets), and the +1\n     * being used for the lower half of the 0'th bucket. Or, equivalently, we need 1 more bucket to capture the max\n     * value if we consider the sub-bucket length to be halved.\n     */\n    AbstractHistogram.prototype.getLengthForNumberOfBuckets = function (numberOfBuckets) {\n        var lengthNeeded = (numberOfBuckets + 1) * (this.subBucketCount / 2);\n        return lengthNeeded;\n    };\n    AbstractHistogram.prototype.getBucketsNeededToCoverValue = function (value) {\n        // the k'th bucket can express from 0 * 2^k to subBucketCount * 2^k in units of 2^k\n        var smallestUntrackableValue = this.subBucketCount * pow(2, this.unitMagnitude);\n        // always have at least 1 bucket\n        var bucketsNeeded = 1;\n        while (smallestUntrackableValue <= value) {\n            if (smallestUntrackableValue > Number.MAX_SAFE_INTEGER / 2) {\n                // TODO check array max size in JavaScript\n                // next shift will overflow, meaning that bucket could represent values up to ones greater than\n                // Number.MAX_SAFE_INTEGER, so it's the last bucket\n                return bucketsNeeded + 1;\n            }\n            smallestUntrackableValue = smallestUntrackableValue * 2;\n            bucketsNeeded++;\n        }\n        return bucketsNeeded;\n    };\n    /**\n     * Record a value in the histogram\n     *\n     * @param value The value to be recorded\n     * @throws may throw Error if value is exceeds highestTrackableValue\n     */\n    AbstractHistogram.prototype.recordValue = function (value) {\n        this.recordSingleValue(value);\n    };\n    AbstractHistogram.prototype.recordSingleValue = function (value) {\n        var countsIndex = this.countsArrayIndex(value);\n        if (countsIndex >= this.countsArrayLength) {\n            this.handleRecordException(1, value);\n        }\n        else {\n            this.incrementCountAtIndex(countsIndex);\n        }\n        this.updateMinAndMax(value);\n        this.incrementTotalCount();\n    };\n    AbstractHistogram.prototype.handleRecordException = function (count, value) {\n        if (!this.autoResize) {\n            throw new Error(\"Value \" + value + \" is outside of histogram covered range\");\n        }\n        this.resize(value);\n        var countsIndex = this.countsArrayIndex(value);\n        this.addToCountAtIndex(countsIndex, count);\n        this.highestTrackableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\n    };\n    AbstractHistogram.prototype.countsArrayIndex = function (value) {\n        if (value < 0) {\n            throw new Error(\"Histogram recorded value cannot be negative.\");\n        }\n        var bucketIndex = this.getBucketIndex(value);\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n        return this.computeCountsArrayIndex(bucketIndex, subBucketIndex);\n    };\n    AbstractHistogram.prototype.computeCountsArrayIndex = function (bucketIndex, subBucketIndex) {\n        // TODO\n        //assert(subBucketIndex < subBucketCount);\n        //assert(bucketIndex == 0 || (subBucketIndex >= subBucketHalfCount));\n        // Calculate the index for the first entry that will be used in the bucket (halfway through subBucketCount).\n        // For bucketIndex 0, all subBucketCount entries may be used, but bucketBaseIndex is still set in the middle.\n        var bucketBaseIndex = (bucketIndex + 1) * pow(2, this.subBucketHalfCountMagnitude);\n        // Calculate the offset in the bucket. This subtraction will result in a positive value in all buckets except\n        // the 0th bucket (since a value in that bucket may be less than half the bucket's 0 to subBucketCount range).\n        // However, this works out since we give bucket 0 twice as much space.\n        var offsetInBucket = subBucketIndex - this.subBucketHalfCount;\n        // The following is the equivalent of ((subBucketIndex  - subBucketHalfCount) + bucketBaseIndex;\n        return bucketBaseIndex + offsetInBucket;\n    };\n    /**\n     * @return the lowest (and therefore highest precision) bucket index that can represent the value\n     */\n    AbstractHistogram.prototype.getBucketIndex = function (value) {\n        // Calculates the number of powers of two by which the value is greater than the biggest value that fits in\n        // bucket 0. This is the bucket index since each successive bucket can hold a value 2x greater.\n        // The mask maps small values to bucket 0.\n        // return this.leadingZeroCountBase - Long.numberOfLeadingZeros(value | subBucketMask);\n        return max(floor(log2(value)) -\n            this.subBucketHalfCountMagnitude -\n            this.unitMagnitude, 0);\n    };\n    AbstractHistogram.prototype.getSubBucketIndex = function (value, bucketIndex) {\n        // For bucketIndex 0, this is just value, so it may be anywhere in 0 to subBucketCount.\n        // For other bucketIndex, this will always end up in the top half of subBucketCount: assume that for some bucket\n        // k > 0, this calculation will yield a value in the bottom half of 0 to subBucketCount. Then, because of how\n        // buckets overlap, it would have also been in the top half of bucket k-1, and therefore would have\n        // returned k-1 in getBucketIndex(). Since we would then shift it one fewer bits here, it would be twice as big,\n        // and therefore in the top half of subBucketCount.\n        return floor(value / pow(2, bucketIndex + this.unitMagnitude));\n    };\n    AbstractHistogram.prototype.updateMinAndMax = function (value) {\n        if (value > this.maxValue) {\n            this.updatedMaxValue(value);\n        }\n        if (value < this.minNonZeroValue && value !== 0) {\n            this.updateMinNonZeroValue(value);\n        }\n    };\n    /**\n     * Get the value at a given percentile.\n     * When the given percentile is &gt; 0.0, the value returned is the value that the given\n     * percentage of the overall recorded value entries in the histogram are either smaller than\n     * or equivalent to. When the given percentile is 0.0, the value returned is the value that all value\n     * entries in the histogram are either larger than or equivalent to.\n     * <p>\n     * Note that two values are \"equivalent\" in this statement if\n     * {@link org.HdrHistogram.AbstractHistogram#valuesAreEquivalent} would return true.\n     *\n     * @param percentile  The percentile for which to return the associated value\n     * @return The value that the given percentage of the overall recorded value entries in the\n     * histogram are either smaller than or equivalent to. When the percentile is 0.0, returns the\n     * value that all value entries in the histogram are either larger than or equivalent to.\n     */\n    AbstractHistogram.prototype.getValueAtPercentile = function (percentile) {\n        var requestedPercentile = min(percentile, 100); // Truncate down to 100%\n        // round count up to nearest integer, to ensure that the largest value that the requested percentile\n        // of overall recorded values is actually included. However, this must be done with care:\n        //\n        // First, Compute fp value for count at the requested percentile. Note that fp result end up\n        // being 1 ulp larger than the correct integer count for this percentile:\n        var fpCountAtPercentile = requestedPercentile / 100.0 * this.getTotalCount();\n        // Next, round up, but make sure to prevent <= 1 ulp inaccurancies in the above fp math from\n        // making us skip a count:\n        var countAtPercentile = max(ceil(fpCountAtPercentile - ulp_1.default(fpCountAtPercentile)), // round up\n        1 // Make sure we at least reach the first recorded entry\n        );\n        var totalToCurrentIndex = 0;\n        for (var i = 0; i < this.countsArrayLength; i++) {\n            totalToCurrentIndex += this.getCountAtIndex(i);\n            if (totalToCurrentIndex >= countAtPercentile) {\n                var valueAtIndex = this.valueFromIndex(i);\n                return percentile === 0.0\n                    ? this.lowestEquivalentValue(valueAtIndex)\n                    : this.highestEquivalentValue(valueAtIndex);\n            }\n        }\n        return 0;\n    };\n    AbstractHistogram.prototype.valueFromIndexes = function (bucketIndex, subBucketIndex) {\n        return subBucketIndex * pow(2, bucketIndex + this.unitMagnitude);\n    };\n    AbstractHistogram.prototype.valueFromIndex = function (index) {\n        var bucketIndex = floor(index / this.subBucketHalfCount) - 1;\n        var subBucketIndex = index % this.subBucketHalfCount + this.subBucketHalfCount;\n        if (bucketIndex < 0) {\n            subBucketIndex -= this.subBucketHalfCount;\n            bucketIndex = 0;\n        }\n        return this.valueFromIndexes(bucketIndex, subBucketIndex);\n    };\n    /**\n     * Get the lowest value that is equivalent to the given value within the histogram's resolution.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The lowest value that is equivalent to the given value within the histogram's resolution.\n     */\n    AbstractHistogram.prototype.lowestEquivalentValue = function (value) {\n        var bucketIndex = this.getBucketIndex(value);\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n        var thisValueBaseLevel = this.valueFromIndexes(bucketIndex, subBucketIndex);\n        return thisValueBaseLevel;\n    };\n    /**\n     * Get the highest value that is equivalent to the given value within the histogram's resolution.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The highest value that is equivalent to the given value within the histogram's resolution.\n     */\n    AbstractHistogram.prototype.highestEquivalentValue = function (value) {\n        return this.nextNonEquivalentValue(value) - 1;\n    };\n    /**\n     * Get the next value that is not equivalent to the given value within the histogram's resolution.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The next value that is not equivalent to the given value within the histogram's resolution.\n     */\n    AbstractHistogram.prototype.nextNonEquivalentValue = function (value) {\n        return (this.lowestEquivalentValue(value) + this.sizeOfEquivalentValueRange(value));\n    };\n    /**\n     * Get the size (in value units) of the range of values that are equivalent to the given value within the\n     * histogram's resolution. Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The size of the range of values equivalent to the given value.\n     */\n    AbstractHistogram.prototype.sizeOfEquivalentValueRange = function (value) {\n        var bucketIndex = this.getBucketIndex(value);\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n        var distanceToNextValue = pow(2, this.unitMagnitude +\n            (subBucketIndex >= this.subBucketCount ? bucketIndex + 1 : bucketIndex));\n        return distanceToNextValue;\n    };\n    /**\n     * Get a value that lies in the middle (rounded up) of the range of values equivalent the given value.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The value lies in the middle (rounded up) of the range of values equivalent the given value.\n     */\n    AbstractHistogram.prototype.medianEquivalentValue = function (value) {\n        return (this.lowestEquivalentValue(value) +\n            floor(this.sizeOfEquivalentValueRange(value) / 2));\n    };\n    /**\n     * Get the computed mean value of all recorded values in the histogram\n     *\n     * @return the mean value (in value units) of the histogram data\n     */\n    AbstractHistogram.prototype.getMean = function () {\n        if (this.getTotalCount() === 0) {\n            return 0;\n        }\n        this.recordedValuesIterator.reset();\n        var totalValue = 0;\n        while (this.recordedValuesIterator.hasNext()) {\n            var iterationValue = this.recordedValuesIterator.next();\n            totalValue +=\n                this.medianEquivalentValue(iterationValue.valueIteratedTo) *\n                    iterationValue.countAtValueIteratedTo;\n        }\n        return totalValue * 1.0 / this.getTotalCount();\n    };\n    /**\n     * Get the computed standard deviation of all recorded values in the histogram\n     *\n     * @return the standard deviation (in value units) of the histogram data\n     */\n    AbstractHistogram.prototype.getStdDeviation = function () {\n        if (this.getTotalCount() === 0) {\n            return 0;\n        }\n        var mean = this.getMean();\n        var geometric_deviation_total = 0.0;\n        this.recordedValuesIterator.reset();\n        while (this.recordedValuesIterator.hasNext()) {\n            var iterationValue = this.recordedValuesIterator.next();\n            var deviation = this.medianEquivalentValue(iterationValue.valueIteratedTo) - mean;\n            geometric_deviation_total +=\n                deviation * deviation * iterationValue.countAddedInThisIterationStep;\n        }\n        var std_deviation = Math.sqrt(geometric_deviation_total / this.getTotalCount());\n        return std_deviation;\n    };\n    /**\n     * Produce textual representation of the value distribution of histogram data by percentile. The distribution is\n     * output with exponentially increasing resolution, with each exponentially decreasing half-distance containing\n     * <i>dumpTicksPerHalf</i> percentile reporting tick points.\n     *\n     * @param printStream    Stream into which the distribution will be output\n     * <p>\n     * @param percentileTicksPerHalfDistance  The number of reporting points per exponentially decreasing half-distance\n     * <p>\n     * @param outputValueUnitScalingRatio    The scaling factor by which to divide histogram recorded values units in\n     *                                     output\n     * @param useCsvFormat  Output in CSV format if true. Otherwise use plain text form.\n     */\n    AbstractHistogram.prototype.outputPercentileDistribution = function (percentileTicksPerHalfDistance, outputValueUnitScalingRatio, useCsvFormat) {\n        if (percentileTicksPerHalfDistance === void 0) { percentileTicksPerHalfDistance = 5; }\n        if (outputValueUnitScalingRatio === void 0) { outputValueUnitScalingRatio = 1; }\n        if (useCsvFormat === void 0) { useCsvFormat = false; }\n        var result = \"\";\n        if (useCsvFormat) {\n            result += '\"Value\",\"Percentile\",\"TotalCount\",\"1/(1-Percentile)\"\\n';\n        }\n        else {\n            result += \"       Value     Percentile TotalCount 1/(1-Percentile)\\n\\n\";\n        }\n        var iterator = this.percentileIterator;\n        iterator.reset(percentileTicksPerHalfDistance);\n        var lineFormatter;\n        var lastLineFormatter;\n        if (useCsvFormat) {\n            var valueFormatter_1 = formatters_1.floatFormatter(0, this.numberOfSignificantValueDigits);\n            var percentileFormatter_1 = formatters_1.floatFormatter(0, 12);\n            var lastFormatter_1 = formatters_1.floatFormatter(0, 2);\n            lineFormatter = function (iterationValue) {\n                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \",\" +\n                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\n                    \",\" +\n                    iterationValue.totalCountToThisValue +\n                    \",\" +\n                    lastFormatter_1(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\n                    \"\\n\";\n            };\n            lastLineFormatter = function (iterationValue) {\n                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \",\" +\n                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\n                    \",\" +\n                    iterationValue.totalCountToThisValue +\n                    \",Infinity\\n\";\n            };\n        }\n        else {\n            var valueFormatter_2 = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\n            var percentileFormatter_2 = formatters_1.floatFormatter(2, 12);\n            var totalCountFormatter_1 = formatters_1.integerFormatter(10);\n            var lastFormatter_2 = formatters_1.floatFormatter(14, 2);\n            lineFormatter = function (iterationValue) {\n                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \" \" +\n                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\n                    \" \" +\n                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\n                    \" \" +\n                    lastFormatter_2(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\n                    \"\\n\";\n            };\n            lastLineFormatter = function (iterationValue) {\n                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \" \" +\n                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\n                    \" \" +\n                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\n                    \"\\n\";\n            };\n        }\n        while (iterator.hasNext()) {\n            var iterationValue = iterator.next();\n            if (iterationValue.percentileLevelIteratedTo < 100) {\n                result += lineFormatter(iterationValue);\n            }\n            else {\n                result += lastLineFormatter(iterationValue);\n            }\n        }\n        if (!useCsvFormat) {\n            // Calculate and output mean and std. deviation.\n            // Note: mean/std. deviation numbers are very often completely irrelevant when\n            // data is extremely non-normal in distribution (e.g. in cases of strong multi-modal\n            // response time distribution associated with GC pauses). However, reporting these numbers\n            // can be very useful for contrasting with the detailed percentile distribution\n            // reported by outputPercentileDistribution(). It is not at all surprising to find\n            // percentile distributions where results fall many tens or even hundreds of standard\n            // deviations away from the mean - such results simply indicate that the data sampled\n            // exhibits a very non-normal distribution, highlighting situations for which the std.\n            // deviation metric is a useless indicator.\n            //\n            var formatter = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\n            var mean = formatter(this.getMean() / outputValueUnitScalingRatio);\n            var std_deviation = formatter(this.getStdDeviation() / outputValueUnitScalingRatio);\n            var max_1 = formatter(this.maxValue / outputValueUnitScalingRatio);\n            var intFormatter = formatters_1.integerFormatter(12);\n            var totalCount = intFormatter(this.getTotalCount());\n            var bucketCount = intFormatter(this.bucketCount);\n            var subBucketCount = intFormatter(this.subBucketCount);\n            result += \"#[Mean    = \" + mean + \", StdDeviation   = \" + std_deviation + \"]\\n#[Max     = \" + max_1 + \", Total count    = \" + totalCount + \"]\\n#[Buckets = \" + bucketCount + \", SubBuckets     = \" + subBucketCount + \"]\\n\";\n        }\n        return result;\n    };\n    /**\n     * Provide a (conservatively high) estimate of the Histogram's total footprint in bytes\n     *\n     * @return a (conservatively high) estimate of the Histogram's total footprint in bytes\n     */\n    AbstractHistogram.prototype.getEstimatedFootprintInBytes = function () {\n        return this._getEstimatedFootprintInBytes();\n    };\n    AbstractHistogram.prototype.recordSingleValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n        this.recordSingleValue(value);\n        if (expectedIntervalBetweenValueSamples <= 0) {\n            return;\n        }\n        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\n            this.recordSingleValue(missingValue);\n        }\n    };\n    AbstractHistogram.prototype.recordCountAtValue = function (count, value) {\n        var countsIndex = this.countsArrayIndex(value);\n        if (countsIndex >= this.countsArrayLength) {\n            this.handleRecordException(count, value);\n        }\n        else {\n            this.addToCountAtIndex(countsIndex, count);\n        }\n        this.updateMinAndMax(value);\n        this.addToTotalCount(count);\n    };\n    /**\n     * Record a value in the histogram (adding to the value's current count)\n     *\n     * @param value The value to be recorded\n     * @param count The number of occurrences of this value to record\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    AbstractHistogram.prototype.recordValueWithCount = function (value, count) {\n        this.recordCountAtValue(count, value);\n    };\n    /**\n     * Record a value in the histogram.\n     * <p>\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\n     * (down to the expectedIntervalBetweenValueSamples) value records.\n     * <p>\n     * Note: This is a at-recording correction method, as opposed to the post-recording correction method provided\n     * by {@link #copyCorrectedForCoordinatedOmission(long)}.\n     * The two methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\n     * for the same coordinated omission issue.\n     * <p>\n     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\n     * important.\n     *\n     * @param value The value to record\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n     *                                           auto-generated value records as appropriate if value is larger\n     *                                           than expectedIntervalBetweenValueSamples\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    AbstractHistogram.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n        this.recordSingleValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\n    };\n    AbstractHistogram.prototype.recordValueWithCountAndExpectedInterval = function (value, count, expectedIntervalBetweenValueSamples) {\n        this.recordCountAtValue(count, value);\n        if (expectedIntervalBetweenValueSamples <= 0) {\n            return;\n        }\n        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\n            this.recordCountAtValue(count, missingValue);\n        }\n    };\n    /**\n     * Add the contents of another histogram to this one, while correcting the incoming data for coordinated omission.\n     * <p>\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n     * interval between value samples, the values added will include an auto-generated additional series of\n     * decreasingly-smaller (down to the expectedIntervalBetweenValueSamples) value records for each count found\n     * in the current histogram that is larger than the expectedIntervalBetweenValueSamples.\n     *\n     * Note: This is a post-recording correction method, as opposed to the at-recording correction method provided\n     * by {@link #recordValueWithExpectedInterval(long, long) recordValueWithExpectedInterval}. The two\n     * methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\n     * for the same coordinated omission issue.\n     * by\n     * <p>\n     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\n     * important.\n     *\n     * @param otherHistogram The other histogram. highestTrackableValue and largestValueWithSingleUnitResolution must match.\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n     *                                           auto-generated value records as appropriate if value is larger\n     *                                           than expectedIntervalBetweenValueSamples\n     * @throws ArrayIndexOutOfBoundsException (may throw) if values exceed highestTrackableValue\n     */\n    AbstractHistogram.prototype.addWhileCorrectingForCoordinatedOmission = function (otherHistogram, expectedIntervalBetweenValueSamples) {\n        var toHistogram = this;\n        var otherValues = new RecordedValuesIterator_1.default(otherHistogram);\n        while (otherValues.hasNext()) {\n            var v = otherValues.next();\n            toHistogram.recordValueWithCountAndExpectedInterval(v.valueIteratedTo, v.countAtValueIteratedTo, expectedIntervalBetweenValueSamples);\n        }\n    };\n    /**\n     * Add the contents of another histogram to this one.\n     * <p>\n     * As part of adding the contents, the start/end timestamp range of this histogram will be\n     * extended to include the start/end timestamp range of the other histogram.\n     *\n     * @param otherHistogram The other histogram.\n     * @throws (may throw) if values in fromHistogram's are\n     * higher than highestTrackableValue.\n     */\n    AbstractHistogram.prototype.add = function (otherHistogram) {\n        var highestRecordableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\n        if (highestRecordableValue < otherHistogram.maxValue) {\n            if (!this.autoResize) {\n                throw new Error(\"The other histogram includes values that do not fit in this histogram's range.\");\n            }\n            this.resize(otherHistogram.maxValue);\n        }\n        if (this.bucketCount === otherHistogram.bucketCount &&\n            this.subBucketCount === otherHistogram.subBucketCount &&\n            this.unitMagnitude === otherHistogram.unitMagnitude) {\n            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\n            var observedOtherTotalCount = 0;\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n                var otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    this.addToCountAtIndex(i, otherCount);\n                    observedOtherTotalCount += otherCount;\n                }\n            }\n            this.setTotalCount(this.getTotalCount() + observedOtherTotalCount);\n            this.updatedMaxValue(max(this.maxValue, otherHistogram.maxValue));\n            this.updateMinNonZeroValue(min(this.minNonZeroValue, otherHistogram.minNonZeroValue));\n        }\n        else {\n            // Arrays are not a direct match (or the other could change on the fly in some valid way),\n            // so we can't just stream through and add them. Instead, go through the array and add each\n            // non-zero value found at it's proper value:\n            // Do max value first, to avoid max value updates on each iteration:\n            var otherMaxIndex = otherHistogram.countsArrayIndex(otherHistogram.maxValue);\n            var otherCount = otherHistogram.getCountAtIndex(otherMaxIndex);\n            this.recordCountAtValue(otherCount, otherHistogram.maxValue);\n            // Record the remaining values, up to but not including the max value:\n            for (var i = 0; i < otherMaxIndex; i++) {\n                otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    this.recordCountAtValue(otherCount, otherHistogram.valueFromIndex(i));\n                }\n            }\n        }\n        this.startTimeStampMsec = min(this.startTimeStampMsec, otherHistogram.startTimeStampMsec);\n        this.endTimeStampMsec = max(this.endTimeStampMsec, otherHistogram.endTimeStampMsec);\n    };\n    /**\n     * Get the count of recorded values at a specific value (to within the histogram resolution at the value level).\n     *\n     * @param value The value for which to provide the recorded count\n     * @return The total count of values recorded in the histogram within the value range that is\n     * {@literal >=} lowestEquivalentValue(<i>value</i>) and {@literal <=} highestEquivalentValue(<i>value</i>)\n     */\n    AbstractHistogram.prototype.getCountAtValue = function (value) {\n        var index = min(max(0, this.countsArrayIndex(value)), this.countsArrayLength - 1);\n        return this.getCountAtIndex(index);\n    };\n    /**\n     * Subtract the contents of another histogram from this one.\n     * <p>\n     * The start/end timestamps of this histogram will remain unchanged.\n     *\n     * @param otherHistogram The other histogram.\n     * @throws ArrayIndexOutOfBoundsException (may throw) if values in otherHistogram's are higher than highestTrackableValue.\n     *\n     */\n    AbstractHistogram.prototype.subtract = function (otherHistogram) {\n        var highestRecordableValue = this.valueFromIndex(this.countsArrayLength - 1);\n        if (highestRecordableValue < otherHistogram.maxValue) {\n            if (!this.autoResize) {\n                throw new Error(\"The other histogram includes values that do not fit in this histogram's range.\");\n            }\n            this.resize(otherHistogram.maxValue);\n        }\n        if (this.bucketCount === otherHistogram.bucketCount &&\n            this.subBucketCount === otherHistogram.subBucketCount &&\n            this.unitMagnitude === otherHistogram.unitMagnitude) {\n            // optim\n            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n                var otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    this.addToCountAtIndex(i, -otherCount);\n                }\n            }\n        }\n        else {\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n                var otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    var otherValue = otherHistogram.valueFromIndex(i);\n                    if (this.getCountAtValue(otherValue) < otherCount) {\n                        throw new Error(\"otherHistogram count (\" +\n                            otherCount +\n                            \") at value \" +\n                            otherValue +\n                            \" is larger than this one's (\" +\n                            this.getCountAtValue(otherValue) +\n                            \")\");\n                    }\n                    this.recordCountAtValue(-otherCount, otherValue);\n                }\n            }\n        }\n        // With subtraction, the max and minNonZero values could have changed:\n        if (this.getCountAtValue(this.maxValue) <= 0 ||\n            this.getCountAtValue(this.minNonZeroValue) <= 0) {\n            this.establishInternalTackingValues();\n        }\n    };\n    AbstractHistogram.prototype.establishInternalTackingValues = function (lengthToCover) {\n        if (lengthToCover === void 0) { lengthToCover = this.countsArrayLength; }\n        this.maxValue = 0;\n        this.minNonZeroValue = Number.MAX_VALUE;\n        var maxIndex = -1;\n        var minNonZeroIndex = -1;\n        var observedTotalCount = 0;\n        for (var index = 0; index < lengthToCover; index++) {\n            var countAtIndex = this.getCountAtIndex(index);\n            if (countAtIndex > 0) {\n                observedTotalCount += countAtIndex;\n                maxIndex = index;\n                if (minNonZeroIndex == -1 && index != 0) {\n                    minNonZeroIndex = index;\n                }\n            }\n        }\n        if (maxIndex >= 0) {\n            this.updatedMaxValue(this.highestEquivalentValue(this.valueFromIndex(maxIndex)));\n        }\n        if (minNonZeroIndex >= 0) {\n            this.updateMinNonZeroValue(this.valueFromIndex(minNonZeroIndex));\n        }\n        this.setTotalCount(observedTotalCount);\n    };\n    AbstractHistogram.prototype.reset = function () {\n        this.clearCounts();\n        this.setTotalCount(0);\n        this.startTimeStampMsec = 0;\n        this.endTimeStampMsec = 0;\n        this.tag = AbstractHistogramBase_1.NO_TAG;\n        this.maxValue = 0;\n        this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\n    };\n    return AbstractHistogram;\n}(AbstractHistogramBase_1.AbstractHistogramBase));\nexports.AbstractHistogram = AbstractHistogram;\nexports.default = AbstractHistogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogram.ts\n// module id = 1\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar EncodableHistogram_1 = require(\"./EncodableHistogram\");\nexports.NO_TAG = \"NO TAG\";\nvar AbstractHistogramBase = /** @class */ (function (_super) {\n    __extends(AbstractHistogramBase, _super);\n    //intermediateUncompressedByteBuffer : ByteBuffer = null;\n    //intermediateUncompressedByteArray : number[] = null;\n    /* useless ?\n    getIntegerToDoubleValueConversionRatio(): number {\n        return this.integerToDoubleValueConversionRatio;\n    }\n  \n    setIntegerToDoubleValueConversionRatio(integerToDoubleValueConversionRatio: number) {\n        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\n    }*/\n    function AbstractHistogramBase() {\n        var _this = _super.call(this) || this;\n        _this.autoResize = false;\n        _this.startTimeStampMsec = Number.MAX_SAFE_INTEGER;\n        _this.endTimeStampMsec = 0;\n        _this.tag = exports.NO_TAG;\n        _this.integerToDoubleValueConversionRatio = 1.0;\n        _this.identity = 0;\n        _this.highestTrackableValue = 0;\n        _this.lowestDiscernibleValue = 0;\n        _this.numberOfSignificantValueDigits = 0;\n        _this.bucketCount = 0;\n        _this.subBucketCount = 0;\n        _this.countsArrayLength = 0;\n        _this.wordSizeInBytes = 0;\n        return _this;\n    }\n    return AbstractHistogramBase;\n}(EncodableHistogram_1.EncodableHistogram));\nexports.AbstractHistogramBase = AbstractHistogramBase;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogramBase.ts\n// module id = 2\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pow = Math.pow, floor = Math.floor;\nvar TWO_POW_32 = pow(2, 32);\n/**\n * Mimic Java's ByteBufffer with big endian order\n */\nvar ByteBuffer = /** @class */ (function () {\n    function ByteBuffer(data) {\n        this.position = 0;\n        this.data = data;\n        this.int32ArrayForConvert = new Uint32Array(1);\n        this.int8ArrayForConvert = new Uint8Array(this.int32ArrayForConvert.buffer);\n    }\n    ByteBuffer.allocate = function (size) {\n        if (size === void 0) { size = 16; }\n        return new ByteBuffer(new Uint8Array(size));\n    };\n    ByteBuffer.prototype.put = function (value) {\n        if (this.position === this.data.length) {\n            var oldArray = this.data;\n            this.data = new Uint8Array(this.data.length * 2);\n            this.data.set(oldArray);\n        }\n        this.data[this.position] = value;\n        this.position++;\n    };\n    ByteBuffer.prototype.putInt32 = function (value) {\n        if (this.data.length - this.position < 4) {\n            var oldArray = this.data;\n            this.data = new Uint8Array(this.data.length * 2 + 4);\n            this.data.set(oldArray);\n        }\n        this.int32ArrayForConvert[0] = value;\n        this.data.set(this.int8ArrayForConvert.reverse(), this.position);\n        this.position += 4;\n    };\n    ByteBuffer.prototype.putInt64 = function (value) {\n        this.putInt32(floor(value / TWO_POW_32));\n        this.putInt32(value);\n    };\n    ByteBuffer.prototype.putArray = function (array) {\n        if (this.data.length - this.position < array.byteLength) {\n            var oldArray = this.data;\n            this.data = new Uint8Array(this.position + array.byteLength);\n            this.data.set(oldArray);\n        }\n        this.data.set(array, this.position);\n        this.position += array.byteLength;\n    };\n    ByteBuffer.prototype.get = function () {\n        var value = this.data[this.position];\n        this.position++;\n        return value;\n    };\n    ByteBuffer.prototype.getInt32 = function () {\n        this.int8ArrayForConvert.set(this.data.slice(this.position, this.position + 4).reverse());\n        var value = this.int32ArrayForConvert[0];\n        this.position += 4;\n        return value;\n    };\n    ByteBuffer.prototype.getInt64 = function () {\n        var high = this.getInt32();\n        var low = this.getInt32();\n        return high * TWO_POW_32 + low;\n    };\n    ByteBuffer.prototype.resetPosition = function () {\n        this.position = 0;\n    };\n    return ByteBuffer;\n}());\nexports.default = ByteBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ByteBuffer.ts\n// module id = 3\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int32Histogram = /** @class */ (function (_super) {\n    __extends(Int32Histogram, _super);\n    function Int32Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Uint32Array(_this.countsArrayLength);\n        return _this;\n    }\n    Int32Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Int32Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int32Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int32Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Int32Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Uint32Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Int32Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Int32Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Int32Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Int32Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Int32Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Int32Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Int32Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + 4 * this.counts.length;\n    };\n    Int32Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Int32Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Int32Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Int32Histogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int32Histogram.ts\n// module id = 4\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\nrequire(\"./AbstractHistogram.encoding\");\nvar base64 = require(\"base64-js\");\nvar decodeFromCompressedBase64 = function (base64String, histogramConstr, minBarForHighestTrackableValue) {\n    if (histogramConstr === void 0) { histogramConstr = Int32Histogram_1.default; }\n    if (minBarForHighestTrackableValue === void 0) { minBarForHighestTrackableValue = 0; }\n    var buffer = new ByteBuffer_1.default(base64.toByteArray(base64String));\n    return AbstractHistogram_1.AbstractHistogram.decodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue);\n};\nexports.decodeFromCompressedBase64 = decodeFromCompressedBase64;\nvar encodeIntoBase64String = function (histogram, compressionLevel) {\n    var buffer = ByteBuffer_1.default.allocate();\n    var bufferSize = histogram.encodeIntoCompressedByteBuffer(buffer, compressionLevel);\n    var encodedBuffer = buffer.data.slice(0, bufferSize);\n    return base64.fromByteArray(encodedBuffer);\n};\nexports.encodeIntoBase64String = encodeIntoBase64String;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/encoding.ts\n// module id = 5\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar HistogramIterationValue_1 = require(\"./HistogramIterationValue\");\n/**\n * Used for iterating through histogram values.\n */\nvar AbstractHistogramIterator /* implements Iterator<HistogramIterationValue> */ = /** @class */ (function () {\n    function AbstractHistogramIterator() {\n        this.currentIterationValue = new HistogramIterationValue_1.default();\n    }\n    AbstractHistogramIterator.prototype.resetIterator = function (histogram) {\n        this.histogram = histogram;\n        this.savedHistogramTotalRawCount = histogram.getTotalCount();\n        this.arrayTotalCount = histogram.getTotalCount();\n        this.currentIndex = 0;\n        this.currentValueAtIndex = 0;\n        this.nextValueAtIndex = Math.pow(2, histogram.unitMagnitude);\n        this.prevValueIteratedTo = 0;\n        this.totalCountToPrevIndex = 0;\n        this.totalCountToCurrentIndex = 0;\n        this.totalValueToCurrentIndex = 0;\n        this.countAtThisValue = 0;\n        this.freshSubBucket = true;\n        this.currentIterationValue.reset();\n    };\n    /**\n     * Returns true if the iteration has more elements. (In other words, returns true if next would return an\n     * element rather than throwing an exception.)\n     *\n     * @return true if the iterator has more elements.\n     */\n    AbstractHistogramIterator.prototype.hasNext = function () {\n        if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\n            throw \"Concurrent Modification Exception\";\n        }\n        return this.totalCountToCurrentIndex < this.arrayTotalCount;\n    };\n    /**\n     * Returns the next element in the iteration.\n     *\n     * @return the {@link HistogramIterationValue} associated with the next element in the iteration.\n     */\n    AbstractHistogramIterator.prototype.next = function () {\n        // Move through the sub buckets and buckets until we hit the next reporting level:\n        while (!this.exhaustedSubBuckets()) {\n            this.countAtThisValue = this.histogram.getCountAtIndex(this.currentIndex);\n            if (this.freshSubBucket) {\n                // Don't add unless we've incremented since last bucket...\n                this.totalCountToCurrentIndex += this.countAtThisValue;\n                this.totalValueToCurrentIndex +=\n                    this.countAtThisValue *\n                        this.histogram.highestEquivalentValue(this.currentValueAtIndex);\n                this.freshSubBucket = false;\n            }\n            if (this.reachedIterationLevel()) {\n                var valueIteratedTo = this.getValueIteratedTo();\n                Object.assign(this.currentIterationValue, {\n                    valueIteratedTo: valueIteratedTo,\n                    valueIteratedFrom: this.prevValueIteratedTo,\n                    countAtValueIteratedTo: this.countAtThisValue,\n                    countAddedInThisIterationStep: this.totalCountToCurrentIndex - this.totalCountToPrevIndex,\n                    totalCountToThisValue: this.totalCountToCurrentIndex,\n                    totalValueToThisValue: this.totalValueToCurrentIndex,\n                    percentile: 100 * this.totalCountToCurrentIndex / this.arrayTotalCount,\n                    percentileLevelIteratedTo: this.getPercentileIteratedTo()\n                });\n                this.prevValueIteratedTo = valueIteratedTo;\n                this.totalCountToPrevIndex = this.totalCountToCurrentIndex;\n                this.incrementIterationLevel();\n                if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\n                    throw new Error(\"Concurrent Modification Exception\");\n                }\n                return this.currentIterationValue;\n            }\n            this.incrementSubBucket();\n        }\n        throw new Error(\"Index Out Of Bounds Exception\");\n    };\n    AbstractHistogramIterator.prototype.getPercentileIteratedTo = function () {\n        return 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\n    };\n    AbstractHistogramIterator.prototype.getPercentileIteratedFrom = function () {\n        return 100 * this.totalCountToPrevIndex / this.arrayTotalCount;\n    };\n    AbstractHistogramIterator.prototype.getValueIteratedTo = function () {\n        return this.histogram.highestEquivalentValue(this.currentValueAtIndex);\n    };\n    AbstractHistogramIterator.prototype.exhaustedSubBuckets = function () {\n        return this.currentIndex >= this.histogram.countsArrayLength;\n    };\n    AbstractHistogramIterator.prototype.incrementSubBucket = function () {\n        this.freshSubBucket = true;\n        this.currentIndex++;\n        this.currentValueAtIndex = this.histogram.valueFromIndex(this.currentIndex);\n        this.nextValueAtIndex = this.histogram.valueFromIndex(this.currentIndex + 1);\n    };\n    return AbstractHistogramIterator;\n}());\nexports.default = AbstractHistogramIterator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogramIterator.ts\n// module id = 6\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar leftPadding = function (size) {\n    return function (input) {\n        if (input.length < size) {\n            return \" \".repeat(size - input.length) + input;\n        }\n        return input;\n    };\n};\nexports.integerFormatter = function (size) {\n    var padding = leftPadding(size);\n    return function (integer) { return padding(\"\" + integer); };\n};\nexports.floatFormatter = function (size, fractionDigits) {\n    var numberFormatter = new Intl.NumberFormat(\"en-US\", {\n        maximumFractionDigits: fractionDigits,\n        minimumFractionDigits: fractionDigits,\n        useGrouping: false\n    });\n    var padding = leftPadding(size);\n    return function (float) { return padding(numberFormatter.format(float)); };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/formatters.ts\n// module id = 7\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"pako\"\n// module id = 8\n// module chunks = 0","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = ((uint8[i] << 16) & 0xFF0000) + ((uint8[i + 1] << 8) & 0xFF00) + (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 9\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar ZigZagEncoding_1 = require(\"./ZigZagEncoding\");\nvar max = Math.max;\nvar V2EncodingCookieBase = 0x1c849303;\nvar V2CompressedEncodingCookieBase = 0x1c849304;\nvar V2maxWordSizeInBytes = 9; // LEB128-64b9B + ZigZag require up to 9 bytes per word\nvar encodingCookie = V2EncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\nvar compressedEncodingCookie = V2CompressedEncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\nfunction fillBufferFromCountsArray(self, buffer) {\n    var countsLimit = self.countsArrayIndex(self.maxValue) + 1;\n    var srcIndex = 0;\n    while (srcIndex < countsLimit) {\n        // V2 encoding format uses a ZigZag LEB128-64b9B encoded long. Positive values are counts,\n        // while negative values indicate a repeat zero counts.\n        var count = self.getCountAtIndex(srcIndex++);\n        if (count < 0) {\n            throw new Error(\"Cannot encode histogram containing negative counts (\" +\n                count +\n                \") at index \" +\n                srcIndex +\n                \", corresponding the value range [\" +\n                self.lowestEquivalentValue(self.valueFromIndex(srcIndex)) +\n                \",\" +\n                self.nextNonEquivalentValue(self.valueFromIndex(srcIndex)) +\n                \")\");\n        }\n        // Count trailing 0s (which follow this count):\n        var zerosCount = 0;\n        if (count == 0) {\n            zerosCount = 1;\n            while (srcIndex < countsLimit && self.getCountAtIndex(srcIndex) == 0) {\n                zerosCount++;\n                srcIndex++;\n            }\n        }\n        if (zerosCount > 1) {\n            ZigZagEncoding_1.default.encode(buffer, -zerosCount);\n        }\n        else {\n            ZigZagEncoding_1.default.encode(buffer, count);\n        }\n    }\n}\n/**\n * Encode this histogram into a ByteBuffer\n * @param buffer The buffer to encode into\n * @return The number of bytes written to the buffer\n */\nfunction encodeIntoByteBuffer(buffer) {\n    var self = this;\n    var initialPosition = buffer.position;\n    buffer.putInt32(encodingCookie);\n    buffer.putInt32(0); // Placeholder for payload length in bytes.\n    buffer.putInt32(1);\n    buffer.putInt32(self.numberOfSignificantValueDigits);\n    buffer.putInt64(self.lowestDiscernibleValue);\n    buffer.putInt64(self.highestTrackableValue);\n    buffer.putInt64(1);\n    var payloadStartPosition = buffer.position;\n    fillBufferFromCountsArray(self, buffer);\n    var backupIndex = buffer.position;\n    buffer.position = initialPosition + 4;\n    buffer.putInt32(backupIndex - payloadStartPosition); // Record the payload length\n    buffer.position = backupIndex;\n    return backupIndex - initialPosition;\n}\nexports.encodeIntoByteBuffer = encodeIntoByteBuffer;\nfunction fillCountsArrayFromSourceBuffer(self, sourceBuffer, lengthInBytes, wordSizeInBytes) {\n    if (wordSizeInBytes != 2 &&\n        wordSizeInBytes != 4 &&\n        wordSizeInBytes != 8 &&\n        wordSizeInBytes != V2maxWordSizeInBytes) {\n        throw new Error(\"word size must be 2, 4, 8, or V2maxWordSizeInBytes (\" +\n            V2maxWordSizeInBytes +\n            \") bytes\");\n    }\n    var dstIndex = 0;\n    var endPosition = sourceBuffer.position + lengthInBytes;\n    while (sourceBuffer.position < endPosition) {\n        var zerosCount = 0;\n        var count = ZigZagEncoding_1.default.decode(sourceBuffer);\n        if (count < 0) {\n            zerosCount = -count;\n            dstIndex += zerosCount; // No need to set zeros in array. Just skip them.\n        }\n        else {\n            self.setCountAtIndex(dstIndex++, count);\n        }\n    }\n    return dstIndex; // this is the destination length\n}\nfunction getCookieBase(cookie) {\n    return cookie & ~0xf0;\n}\nfunction getWordSizeInBytesFromCookie(cookie) {\n    if (getCookieBase(cookie) == V2EncodingCookieBase ||\n        getCookieBase(cookie) == V2CompressedEncodingCookieBase) {\n        return V2maxWordSizeInBytes;\n    }\n    var sizeByte = (cookie & 0xf0) >> 4;\n    return sizeByte & 0xe;\n}\nfunction doDecodeFromByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue) {\n    var cookie = buffer.getInt32();\n    var payloadLengthInBytes;\n    var numberOfSignificantValueDigits;\n    var lowestTrackableUnitValue;\n    var highestTrackableValue;\n    if (getCookieBase(cookie) === V2EncodingCookieBase) {\n        if (getWordSizeInBytesFromCookie(cookie) != V2maxWordSizeInBytes) {\n            throw new Error(\"The buffer does not contain a Histogram (no valid cookie found)\");\n        }\n        payloadLengthInBytes = buffer.getInt32();\n        buffer.getInt32(); // normalizingIndexOffset not used\n        numberOfSignificantValueDigits = buffer.getInt32();\n        lowestTrackableUnitValue = buffer.getInt64();\n        highestTrackableValue = buffer.getInt64();\n        buffer.getInt64(); // integerToDoubleValueConversionRatio not used\n    }\n    else {\n        throw new Error(\"The buffer does not contain a Histogram (no valid V2 encoding cookie found)\");\n    }\n    highestTrackableValue = max(highestTrackableValue, minBarForHighestTrackableValue);\n    var histogram = new histogramConstr(lowestTrackableUnitValue, highestTrackableValue, numberOfSignificantValueDigits);\n    var filledLength = fillCountsArrayFromSourceBuffer(histogram, buffer, payloadLengthInBytes, V2maxWordSizeInBytes);\n    histogram.establishInternalTackingValues(filledLength);\n    return histogram;\n}\nexports.doDecodeFromByteBuffer = doDecodeFromByteBuffer;\nfunction doDecodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue) {\n    var initialTargetPosition = buffer.position;\n    var cookie = buffer.getInt32();\n    if ((cookie & ~0xf0) !== V2CompressedEncodingCookieBase) {\n        throw new Error(\"Encoding not supported, only V2 is supported\");\n    }\n    var lengthOfCompressedContents = buffer.getInt32();\n    var pako = require(\"pako/lib/inflate\");\n    var uncompressedBuffer = pako.inflate(buffer.data.slice(initialTargetPosition + 8, initialTargetPosition + 8 + lengthOfCompressedContents));\n    return doDecodeFromByteBuffer(new ByteBuffer_1.default(uncompressedBuffer), histogramConstr, minBarForHighestTrackableValue);\n}\nexports.doDecodeFromCompressedByteBuffer = doDecodeFromCompressedByteBuffer;\n/**\n * Encode this histogram in compressed form into a byte array\n * @param targetBuffer The buffer to encode into\n * @return The number of bytes written to the array\n */\nfunction encodeIntoCompressedByteBuffer(targetBuffer, compressionLevel) {\n    var self = this;\n    var intermediateUncompressedByteBuffer = ByteBuffer_1.default.allocate();\n    var uncompressedLength = self.encodeIntoByteBuffer(intermediateUncompressedByteBuffer);\n    targetBuffer.putInt32(compressedEncodingCookie);\n    var pako = require(\"pako/lib/deflate\");\n    var compressionOptions = compressionLevel\n        ? { level: compressionLevel }\n        : {};\n    var compressedArray = pako.deflate(intermediateUncompressedByteBuffer.data.slice(0, uncompressedLength), compressionOptions);\n    targetBuffer.putInt32(compressedArray.byteLength);\n    targetBuffer.putArray(compressedArray);\n    return targetBuffer.position;\n}\nexports.encodeIntoCompressedByteBuffer = encodeIntoCompressedByteBuffer;\nAbstractHistogram_1.AbstractHistogram.decodeFromByteBuffer = doDecodeFromByteBuffer;\nAbstractHistogram_1.AbstractHistogram.decodeFromCompressedByteBuffer = doDecodeFromCompressedByteBuffer;\nAbstractHistogram_1.AbstractHistogram.prototype.encodeIntoByteBuffer = encodeIntoByteBuffer;\nAbstractHistogram_1.AbstractHistogram.prototype.encodeIntoCompressedByteBuffer = encodeIntoCompressedByteBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogram.encoding.ts\n// module id = 10\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EncodableHistogram = /** @class */ (function () {\n    function EncodableHistogram() {\n    }\n    return EncodableHistogram;\n}());\nexports.EncodableHistogram = EncodableHistogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/EncodableHistogram.ts\n// module id = 11\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Float64Histogram = /** @class */ (function (_super) {\n    __extends(Float64Histogram, _super);\n    function Float64Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Float64Array(_this.countsArrayLength);\n        return _this;\n    }\n    Float64Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Float64Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Float64Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Float64Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Float64Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Float64Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Float64Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Float64Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Float64Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Float64Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Float64Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Float64Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Float64Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + 8 * this.counts.length;\n    };\n    Float64Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Float64Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Float64Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Float64Histogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Float64Histogram.ts\n// module id = 12\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Represents a value point iterated through in a Histogram, with associated stats.\n * <ul>\n * <li><b><code>valueIteratedTo</code></b> :<br> The actual value level that was iterated to by the iterator</li>\n * <li><b><code>prevValueIteratedTo</code></b> :<br> The actual value level that was iterated from by the iterator</li>\n * <li><b><code>countAtValueIteratedTo</code></b> :<br> The count of recorded values in the histogram that\n * exactly match this [lowestEquivalentValue(valueIteratedTo)...highestEquivalentValue(valueIteratedTo)] value\n * range.</li>\n * <li><b><code>countAddedInThisIterationStep</code></b> :<br> The count of recorded values in the histogram that\n * were added to the totalCountToThisValue (below) as a result on this iteration step. Since multiple iteration\n * steps may occur with overlapping equivalent value ranges, the count may be lower than the count found at\n * the value (e.g. multiple linear steps or percentile levels can occur within a single equivalent value range)</li>\n * <li><b><code>totalCountToThisValue</code></b> :<br> The total count of all recorded values in the histogram at\n * values equal or smaller than valueIteratedTo.</li>\n * <li><b><code>totalValueToThisValue</code></b> :<br> The sum of all recorded values in the histogram at values\n * equal or smaller than valueIteratedTo.</li>\n * <li><b><code>percentile</code></b> :<br> The percentile of recorded values in the histogram at values equal\n * or smaller than valueIteratedTo.</li>\n * <li><b><code>percentileLevelIteratedTo</code></b> :<br> The percentile level that the iterator returning this\n * HistogramIterationValue had iterated to. Generally, percentileLevelIteratedTo will be equal to or smaller than\n * percentile, but the same value point can contain multiple iteration levels for some iterators. E.g. a\n * PercentileIterator can stop multiple times in the exact same value point (if the count at that value covers a\n * range of multiple percentiles in the requested percentile iteration points).</li>\n * </ul>\n */\nvar HistogramIterationValue = /** @class */ (function () {\n    function HistogramIterationValue() {\n        this.reset();\n    }\n    HistogramIterationValue.prototype.reset = function () {\n        this.valueIteratedTo = 0;\n        this.valueIteratedFrom = 0;\n        this.countAtValueIteratedTo = 0;\n        this.countAddedInThisIterationStep = 0;\n        this.totalCountToThisValue = 0;\n        this.totalValueToThisValue = 0;\n        this.percentile = 0.0;\n        this.percentileLevelIteratedTo = 0.0;\n    };\n    return HistogramIterationValue;\n}());\nexports.default = HistogramIterationValue;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramIterationValue.ts\n// module id = 13\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\nvar encoding_1 = require(\"./encoding\");\nvar TAG_PREFIX = \"Tag=\";\nvar TAG_PREFIX_LENGTH = \"Tag=\".length;\n/**\n * A histogram log reader.\n * <p>\n * Histogram logs are used to capture full fidelity, per-time-interval\n * histograms of a recorded value.\n * <p>\n * For example, a histogram log can be used to capture high fidelity\n * reaction-time logs for some measured system or subsystem component.\n * Such a log would capture a full reaction time histogram for each\n * logged interval, and could be used to later reconstruct a full\n * HdrHistogram of the measured reaction time behavior for any arbitrary\n * time range within the log, by adding [only] the relevant interval\n * histograms.\n * <h3>Histogram log format:</h3>\n * A histogram log file consists of text lines. Lines beginning with\n * the \"#\" character are optional and treated as comments. Lines\n * containing the legend (starting with \"Timestamp\") are also optional\n * and ignored in parsing the histogram log. All other lines must\n * be valid interval description lines. Text fields are delimited by\n * commas, spaces.\n * <p>\n * A valid interval description line contains an optional Tag=tagString\n * text field, followed by an interval description.\n * <p>\n * A valid interval description must contain exactly four text fields:\n * <ul>\n * <li>StartTimestamp: The first field must contain a number parse-able as a Double value,\n * representing the start timestamp of the interval in seconds.</li>\n * <li>intervalLength: The second field must contain a number parse-able as a Double value,\n * representing the length of the interval in seconds.</li>\n * <li>Interval_Max: The third field must contain a number parse-able as a Double value,\n * which generally represents the maximum value of the interval histogram.</li>\n * <li>Interval_Compressed_Histogram: The fourth field must contain a text field\n * parse-able as a Base64 text representation of a compressed HdrHistogram.</li>\n * </ul>\n * The log file may contain an optional indication of a starting time. Starting time\n * is indicated using a special comments starting with \"#[StartTime: \" and followed\n * by a number parse-able as a double, representing the start time (in seconds)\n * that may be added to timestamps in the file to determine an absolute\n * timestamp (e.g. since the epoch) for each interval.\n */\nvar HistogramLogReader = /** @class */ (function () {\n    function HistogramLogReader(logContent) {\n        this.lines = splitLines(logContent);\n        this.currentLineIndex = 0;\n    }\n    /**\n     * Read the next interval histogram from the log. Returns a Histogram object if\n     * an interval line was found, or null if not.\n     * <p>Upon encountering any unexpected format errors in reading the next interval\n     * from the file, this method will return a null.\n     * @return a DecodedInterval, or a null if no appropriate interval found\n     */\n    HistogramLogReader.prototype.nextIntervalHistogram = function (rangeStartTimeSec, rangeEndTimeSec) {\n        if (rangeStartTimeSec === void 0) { rangeStartTimeSec = 0; }\n        if (rangeEndTimeSec === void 0) { rangeEndTimeSec = Number.MAX_VALUE; }\n        while (this.currentLineIndex < this.lines.length) {\n            var currentLine = this.lines[this.currentLineIndex];\n            this.currentLineIndex++;\n            if (currentLine.startsWith(\"#[StartTime:\")) {\n                this.parseStartTimeFromLine(currentLine);\n            }\n            else if (currentLine.startsWith(\"#[BaseTime:\")) {\n                this.parseBaseTimeFromLine(currentLine);\n            }\n            else if (currentLine.startsWith(\"#\") ||\n                currentLine.startsWith('\"StartTimestamp\"')) {\n                // skip legend & meta data for now\n            }\n            else if (currentLine.includes(\",\")) {\n                var tokens = currentLine.split(\",\");\n                var firstToken = tokens[0];\n                var tag = void 0;\n                if (firstToken.startsWith(TAG_PREFIX)) {\n                    tag = firstToken.substring(TAG_PREFIX_LENGTH);\n                    tokens.shift();\n                }\n                else {\n                    tag = AbstractHistogramBase_1.NO_TAG;\n                }\n                var rawLogTimeStampInSec = tokens[0], rawIntervalLengthSec = tokens[1], base64Histogram = tokens[3];\n                var logTimeStampInSec = Number.parseFloat(rawLogTimeStampInSec);\n                if (!this.baseTimeSec) {\n                    // No explicit base time noted. Deduce from 1st observed time (compared to start time):\n                    if (logTimeStampInSec < this.startTimeSec - 365 * 24 * 3600.0) {\n                        // Criteria Note: if log timestamp is more than a year in the past (compared to\n                        // StartTime), we assume that timestamps in the log are not absolute\n                        this.baseTimeSec = this.startTimeSec;\n                    }\n                    else {\n                        // Timestamps are absolute\n                        this.baseTimeSec = 0.0;\n                    }\n                }\n                if (rangeEndTimeSec < logTimeStampInSec) {\n                    return null;\n                }\n                if (logTimeStampInSec < rangeStartTimeSec) {\n                    continue;\n                }\n                var histogram = encoding_1.decodeFromCompressedBase64(base64Histogram);\n                histogram.startTimeStampMsec =\n                    (this.baseTimeSec + logTimeStampInSec) * 1000;\n                var intervalLengthSec = Number.parseFloat(rawIntervalLengthSec);\n                histogram.endTimeStampMsec =\n                    (this.baseTimeSec + logTimeStampInSec + intervalLengthSec) * 1000;\n                histogram.tag = tag;\n                return histogram;\n            }\n        }\n        return null;\n    };\n    HistogramLogReader.prototype.parseStartTimeFromLine = function (line) {\n        this.startTimeSec = Number.parseFloat(line.split(\" \")[1]);\n    };\n    HistogramLogReader.prototype.parseBaseTimeFromLine = function (line) {\n        this.baseTimeSec = Number.parseFloat(line.split(\" \")[1]);\n    };\n    return HistogramLogReader;\n}());\nvar splitLines = function (logContent) { return logContent.split(/\\r\\n|\\r|\\n/g); };\nvar shouldIncludeNoTag = function (lines) {\n    return lines.find(function (line) {\n        return !line.startsWith(\"#\") &&\n            !line.startsWith('\"') &&\n            !line.startsWith(TAG_PREFIX) &&\n            line.includes(\",\");\n    });\n};\nexports.listTags = function (content) {\n    var lines = splitLines(content);\n    var tags = lines\n        .filter(function (line) { return line.includes(\",\") && line.startsWith(TAG_PREFIX); })\n        .map(function (line) { return line.substring(TAG_PREFIX_LENGTH, line.indexOf(\",\")); });\n    var tagsWithoutDuplicates = new Set(tags);\n    var result = Array.from(tagsWithoutDuplicates);\n    if (shouldIncludeNoTag(lines)) {\n        result.unshift(\"NO TAG\");\n    }\n    return result;\n};\nexports.default = HistogramLogReader;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramLogReader.ts\n// module id = 14\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\nvar encoding_1 = require(\"./encoding\");\nvar formatters_1 = require(\"./formatters\");\nvar HISTOGRAM_LOG_FORMAT_VERSION = \"1.3\";\nvar timeFormatter = formatters_1.floatFormatter(5, 3);\nvar HistogramLogWriter = /** @class */ (function () {\n    function HistogramLogWriter(log) {\n        this.log = log;\n        /**\n         * Base time to subtract from supplied histogram start/end timestamps when\n         * logging based on histogram timestamps.\n         * Base time is expected to be in msec since the epoch, as histogram start/end times\n         * are typically stamped with absolute times in msec since the epoch.\n         */\n        this.baseTime = 0;\n    }\n    /**\n     * Output an interval histogram, with the given timestamp information and the [optional] tag\n     * associated with the histogram, using a configurable maxValueUnitRatio. (note that the\n     * specified timestamp information will be used, and the timestamp information in the actual\n     * histogram will be ignored).\n     * The max value reported with the interval line will be scaled by the given maxValueUnitRatio.\n     * @param startTimeStampSec The start timestamp to log with the interval histogram, in seconds.\n     * @param endTimeStampSec The end timestamp to log with the interval histogram, in seconds.\n     * @param histogram The interval histogram to log.\n     * @param maxValueUnitRatio The ratio by which to divide the histogram's max value when reporting on it.\n     */\n    HistogramLogWriter.prototype.outputIntervalHistogram = function (histogram, startTimeStampSec, endTimeStampSec, maxValueUnitRatio) {\n        if (startTimeStampSec === void 0) { startTimeStampSec = (histogram.startTimeStampMsec - this.baseTime) / 1000; }\n        if (endTimeStampSec === void 0) { endTimeStampSec = (histogram.endTimeStampMsec - this.baseTime) / 1000; }\n        if (maxValueUnitRatio === void 0) { maxValueUnitRatio = 1000; }\n        var base64 = encoding_1.encodeIntoBase64String(histogram);\n        var start = timeFormatter(startTimeStampSec);\n        var duration = timeFormatter(endTimeStampSec - startTimeStampSec);\n        var max = timeFormatter(histogram.maxValue / maxValueUnitRatio);\n        var lineContent = start + \",\" + duration + \",\" + max + \",\" + base64 + \"\\n\";\n        if (histogram.tag && histogram.tag !== AbstractHistogramBase_1.NO_TAG) {\n            this.log(\"Tag=\" + histogram.tag + \",\" + lineContent);\n        }\n        else {\n            this.log(lineContent);\n        }\n    };\n    /**\n     * Log a comment to the log.\n     * Comments will be preceded with with the '#' character.\n     * @param comment the comment string.\n     */\n    HistogramLogWriter.prototype.outputComment = function (comment) {\n        this.log(\"#\" + comment + \"\\n\");\n    };\n    /**\n     * Log a start time in the log.\n     * @param startTimeMsec time (in milliseconds) since the absolute start time (the epoch)\n     */\n    HistogramLogWriter.prototype.outputStartTime = function (startTimeMsec) {\n        this.outputComment(\"[StartTime: \" + formatters_1.floatFormatter(5, 3)(startTimeMsec / 1000) + \" (seconds since epoch), \" + new Date(startTimeMsec) + \"]\\n\");\n    };\n    /**\n     * Output a legend line to the log.\n     */\n    HistogramLogWriter.prototype.outputLegend = function () {\n        this.log('\"StartTimestamp\",\"Interval_Length\",\"Interval_Max\",\"Interval_Compressed_Histogram\"\\n');\n    };\n    /**\n     * Output a log format version to the log.\n     */\n    HistogramLogWriter.prototype.outputLogFormatVersion = function () {\n        this.outputComment(\"[Histogram log format version \" + HISTOGRAM_LOG_FORMAT_VERSION + \"]\");\n    };\n    return HistogramLogWriter;\n}());\nexports.default = HistogramLogWriter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramLogWriter.ts\n// module id = 15\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int16Histogram = /** @class */ (function (_super) {\n    __extends(Int16Histogram, _super);\n    function Int16Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Uint16Array(_this.countsArrayLength);\n        return _this;\n    }\n    Int16Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Int16Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int16Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int16Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Int16Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Uint16Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Int16Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Int16Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Int16Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Int16Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Int16Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Int16Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Int16Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + 2 * this.counts.length;\n    };\n    Int16Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Int16Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Int16Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Int16Histogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int16Histogram.ts\n// module id = 16\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int8Histogram = /** @class */ (function (_super) {\n    __extends(Int8Histogram, _super);\n    function Int8Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Uint8Array(_this.countsArrayLength);\n        return _this;\n    }\n    Int8Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Int8Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int8Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int8Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Int8Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Uint8Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Int8Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Int8Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Int8Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Int8Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Int8Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Int8Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Int8Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + this.counts.length;\n    };\n    Int8Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Int8Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Int8Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Int8Histogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int8Histogram.ts\n// module id = 17\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractHistogramIterator_1 = require(\"./AbstractHistogramIterator\");\nvar pow = Math.pow, floor = Math.floor, log2 = Math.log2;\n/**\n * Used for iterating through histogram values according to percentile levels. The iteration is\n * performed in steps that start at 0% and reduce their distance to 100% according to the\n * <i>percentileTicksPerHalfDistance</i> parameter, ultimately reaching 100% when all recorded histogram\n * values are exhausted.\n */\nvar PercentileIterator = /** @class */ (function (_super) {\n    __extends(PercentileIterator, _super);\n    /**\n     * @param histogram The histogram this iterator will operate on\n     * @param percentileTicksPerHalfDistance The number of equal-sized iteration steps per half-distance to 100%.\n     */\n    function PercentileIterator(histogram, percentileTicksPerHalfDistance) {\n        var _this = _super.call(this) || this;\n        _this.percentileTicksPerHalfDistance = 0;\n        _this.percentileLevelToIterateTo = 0;\n        _this.percentileLevelToIterateFrom = 0;\n        _this.reachedLastRecordedValue = false;\n        _this.doReset(histogram, percentileTicksPerHalfDistance);\n        return _this;\n    }\n    /**\n     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\n     *\n     * @param percentileTicksPerHalfDistance The number of iteration steps per half-distance to 100%.\n     */\n    PercentileIterator.prototype.reset = function (percentileTicksPerHalfDistance) {\n        this.doReset(this.histogram, percentileTicksPerHalfDistance);\n    };\n    PercentileIterator.prototype.doReset = function (histogram, percentileTicksPerHalfDistance) {\n        _super.prototype.resetIterator.call(this, histogram);\n        this.percentileTicksPerHalfDistance = percentileTicksPerHalfDistance;\n        this.percentileLevelToIterateTo = 0;\n        this.percentileLevelToIterateFrom = 0;\n        this.reachedLastRecordedValue = false;\n    };\n    PercentileIterator.prototype.hasNext = function () {\n        if (_super.prototype.hasNext.call(this))\n            return true;\n        if (!this.reachedLastRecordedValue && this.arrayTotalCount > 0) {\n            this.percentileLevelToIterateTo = 100;\n            this.reachedLastRecordedValue = true;\n            return true;\n        }\n        return false;\n    };\n    PercentileIterator.prototype.incrementIterationLevel = function () {\n        this.percentileLevelToIterateFrom = this.percentileLevelToIterateTo;\n        // The choice to maintain fixed-sized \"ticks\" in each half-distance to 100% [starting\n        // from 0%], as opposed to a \"tick\" size that varies with each interval, was made to\n        // make the steps easily comprehensible and readable to humans. The resulting percentile\n        // steps are much easier to browse through in a percentile distribution output, for example.\n        //\n        // We calculate the number of equal-sized \"ticks\" that the 0-100 range will be divided\n        // by at the current scale. The scale is detemined by the percentile level we are\n        // iterating to. The following math determines the tick size for the current scale,\n        // and maintain a fixed tick size for the remaining \"half the distance to 100%\"\n        // [from either 0% or from the previous half-distance]. When that half-distance is\n        // crossed, the scale changes and the tick size is effectively cut in half.\n        // percentileTicksPerHalfDistance = 5\n        // percentileReportingTicks = 10,\n        var percentileReportingTicks = this.percentileTicksPerHalfDistance *\n            pow(2, floor(log2(100 / (100 - this.percentileLevelToIterateTo))) + 1);\n        this.percentileLevelToIterateTo += 100 / percentileReportingTicks;\n    };\n    PercentileIterator.prototype.reachedIterationLevel = function () {\n        if (this.countAtThisValue === 0) {\n            return false;\n        }\n        var currentPercentile = 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\n        return currentPercentile >= this.percentileLevelToIterateTo;\n    };\n    PercentileIterator.prototype.getPercentileIteratedTo = function () {\n        return this.percentileLevelToIterateTo;\n    };\n    PercentileIterator.prototype.getPercentileIteratedFrom = function () {\n        return this.percentileLevelToIterateFrom;\n    };\n    return PercentileIterator;\n}(AbstractHistogramIterator_1.default));\nexports.default = PercentileIterator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/PercentileIterator.ts\n// module id = 18\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractHistogramIterator_1 = require(\"./AbstractHistogramIterator\");\n/**\n * Used for iterating through all recorded histogram values using the finest granularity steps supported by the\n * underlying representation. The iteration steps through all non-zero recorded value counts, and terminates when\n * all recorded histogram values are exhausted.\n */\nvar RecordedValuesIterator = /** @class */ (function (_super) {\n    __extends(RecordedValuesIterator, _super);\n    /**\n     * @param histogram The histogram this iterator will operate on\n     */\n    function RecordedValuesIterator(histogram) {\n        var _this = _super.call(this) || this;\n        _this.doReset(histogram);\n        return _this;\n    }\n    /**\n     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\n     */\n    RecordedValuesIterator.prototype.reset = function () {\n        this.doReset(this.histogram);\n    };\n    RecordedValuesIterator.prototype.doReset = function (histogram) {\n        _super.prototype.resetIterator.call(this, histogram);\n        this.visitedIndex = -1;\n    };\n    RecordedValuesIterator.prototype.incrementIterationLevel = function () {\n        this.visitedIndex = this.currentIndex;\n    };\n    RecordedValuesIterator.prototype.reachedIterationLevel = function () {\n        var currentCount = this.histogram.getCountAtIndex(this.currentIndex);\n        return currentCount != 0 && this.visitedIndex !== this.currentIndex;\n    };\n    return RecordedValuesIterator;\n}(AbstractHistogramIterator_1.default));\nexports.default = RecordedValuesIterator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/RecordedValuesIterator.ts\n// module id = 19\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\n/**\n * Records integer values, and provides stable interval {@link Histogram} samples from\n * live recorded data without interrupting or stalling active recording of values. Each interval\n * histogram provided contains all value counts accumulated since the previous interval histogram\n * was taken.\n * <p>\n * This pattern is commonly used in logging interval histogram information while recording is ongoing.\n * <p>\n * {@link Recorder} supports concurrent\n * {@link Recorder#recordValue} or\n * {@link Recorder#recordValueWithExpectedInterval} calls.\n *\n */\nvar Recorder = /** @class */ (function () {\n    /**\n     * Construct an auto-resizing {@link Recorder} with a lowest discernible value of\n     * 1 and an auto-adjusting highestTrackableValue. Can auto-resize up to track values up to Number.MAX_SAFE_INTEGER.\n     *\n     * @param numberOfSignificantValueDigits Specifies the precision to use. This is the number of significant\n     *                                       decimal digits to which the histogram will maintain value resolution\n     *                                       and separation. Must be a non-negative integer between 0 and 5.\n     * @param clock (for testing purpose) an action that give current time in ms since 1970\n     */\n    function Recorder(numberOfSignificantValueDigits, clock) {\n        if (numberOfSignificantValueDigits === void 0) { numberOfSignificantValueDigits = 3; }\n        if (clock === void 0) { clock = function () { return new Date().getTime(); }; }\n        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\n        this.clock = clock;\n        this.activeHistogram = new Int32Histogram_1.default(1, Number.MAX_SAFE_INTEGER, numberOfSignificantValueDigits);\n        Recorder.idGenerator++;\n        this.activeHistogram.containingInstanceId = Recorder.idGenerator;\n        this.activeHistogram.startTimeStampMsec = clock();\n    }\n    /**\n     * Record a value in the histogram\n     *\n     * @param value The value to be recorded\n     * @throws may throw Error if value is exceeds highestTrackableValue\n     */\n    Recorder.prototype.recordValue = function (value) {\n        this.activeHistogram.recordValue(value);\n    };\n    /**\n     * Record a value in the histogram (adding to the value's current count)\n     *\n     * @param value The value to be recorded\n     * @param count The number of occurrences of this value to record\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    Recorder.prototype.recordValueWithCount = function (value, count) {\n        this.activeHistogram.recordValueWithCount(value, count);\n    };\n    /**\n     * Record a value\n     * <p>\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\n     * (down to the expectedIntervalBetweenValueSamples) value records.\n     * <p>\n     * See related notes {@link AbstractHistogram#recordValueWithExpectedInterval(long, long)}\n     * for more explanations about coordinated omission and expected interval correction.\n     *      *\n     * @param value The value to record\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n     *                                           auto-generated value records as appropriate if value is larger\n     *                                           than expectedIntervalBetweenValueSamples\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    Recorder.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n        this.activeHistogram.recordValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\n    };\n    /**\n     * Get an interval histogram, which will include a stable, consistent view of all value counts\n     * accumulated since the last interval histogram was taken.\n     * <p>\n     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n     * getIntervalHistogram(histogramToRecycle)}\n     * accepts a previously returned interval histogram that can be recycled internally to avoid allocation\n     * and content copying operations, and is therefore significantly more efficient for repeated use than\n     * {@link Recorder#getIntervalHistogram()} and\n     * {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()}. The provided\n     * {@code histogramToRecycle} must\n     * be either be null or an interval histogram returned by a previous call to\n     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n     * getIntervalHistogram(histogramToRecycle)} or\n     * {@link Recorder#getIntervalHistogram()}.\n     * <p>\n     * NOTE: The caller is responsible for not recycling the same returned interval histogram more than once. If\n     * the same interval histogram instance is recycled more than once, behavior is undefined.\n     * <p>\n     * Calling {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n     * getIntervalHistogram(histogramToRecycle)} will reset the value counts, and start accumulating value\n     * counts for the next interval\n     *\n     * @param histogramToRecycle a previously returned interval histogram that may be recycled to avoid allocation and\n     *                           copy operations.\n     * @return a histogram containing the value counts accumulated since the last interval histogram was taken.\n     */\n    Recorder.prototype.getIntervalHistogram = function (histogramToRecycle) {\n        if (histogramToRecycle) {\n            var histogramToRecycleWithId = histogramToRecycle;\n            if (histogramToRecycleWithId.containingInstanceId !==\n                this.activeHistogram.containingInstanceId) {\n                throw \"replacement histogram must have been obtained via a previous getIntervalHistogram() call from this Recorder\";\n            }\n        }\n        this.inactiveHistogram = histogramToRecycle;\n        this.performIntervalSample();\n        var sampledHistogram = this.inactiveHistogram;\n        this.inactiveHistogram = null; // Once we expose the sample, we can't reuse it internally until it is recycled\n        return sampledHistogram;\n    };\n    /**\n     * Place a copy of the value counts accumulated since accumulated (since the last interval histogram\n     * was taken) into {@code targetHistogram}.\n     *\n     * Calling {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()} will reset\n     * the value counts, and start accumulating value counts for the next interval.\n     *\n     * @param targetHistogram the histogram into which the interval histogram's data should be copied\n     */\n    Recorder.prototype.getIntervalHistogramInto = function (targetHistogram) {\n        this.performIntervalSample();\n        if (this.inactiveHistogram) {\n            targetHistogram.add(this.inactiveHistogram);\n            targetHistogram.startTimeStampMsec = this.inactiveHistogram.startTimeStampMsec;\n            targetHistogram.endTimeStampMsec = this.inactiveHistogram.endTimeStampMsec;\n        }\n    };\n    /**\n     * Reset any value counts accumulated thus far.\n     */\n    Recorder.prototype.reset = function () {\n        this.activeHistogram.reset();\n        this.activeHistogram.startTimeStampMsec = this.clock();\n    };\n    Recorder.prototype.performIntervalSample = function () {\n        if (!this.inactiveHistogram) {\n            this.inactiveHistogram = new Int32Histogram_1.default(1, Number.MAX_SAFE_INTEGER, this.numberOfSignificantValueDigits);\n            this.inactiveHistogram.containingInstanceId = this.activeHistogram.containingInstanceId;\n        }\n        this.inactiveHistogram.reset();\n        var tempHistogram = this.activeHistogram;\n        this.activeHistogram = this.inactiveHistogram;\n        this.inactiveHistogram = tempHistogram;\n        var currentTimeInMs = this.clock();\n        this.inactiveHistogram.endTimeStampMsec = currentTimeInMs;\n        this.activeHistogram.startTimeStampMsec = currentTimeInMs;\n    };\n    Recorder.idGenerator = 0;\n    return Recorder;\n}());\nexports.default = Recorder;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Recorder.ts\n// module id = 20\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pow = Math.pow, floor = Math.floor;\nvar TWO_POW_7 = pow(2, 7);\nvar TWO_POW_14 = pow(2, 14);\nvar TWO_POW_21 = pow(2, 21);\nvar TWO_POW_28 = pow(2, 28);\nvar TWO_POW_35 = pow(2, 35);\nvar TWO_POW_42 = pow(2, 42);\nvar TWO_POW_49 = pow(2, 49);\nvar TWO_POW_56 = pow(2, 56);\n/**\n * This class provides encoding and decoding methods for writing and reading\n * ZigZag-encoded LEB128-64b9B-variant (Little Endian Base 128) values to/from a\n * {@link ByteBuffer}. LEB128's variable length encoding provides for using a\n * smaller nuber of bytes for smaller values, and the use of ZigZag encoding\n * allows small (closer to zero) negative values to use fewer bytes. Details\n * on both LEB128 and ZigZag can be readily found elsewhere.\n *\n * The LEB128-64b9B-variant encoding used here diverges from the \"original\"\n * LEB128 as it extends to 64 bit values: In the original LEB128, a 64 bit\n * value can take up to 10 bytes in the stream, where this variant's encoding\n * of a 64 bit values will max out at 9 bytes.\n *\n * As such, this encoder/decoder should NOT be used for encoding or decoding\n * \"standard\" LEB128 formats (e.g. Google Protocol Buffers).\n */\nvar ZigZagEncoding = /** @class */ (function () {\n    function ZigZagEncoding() {\n    }\n    /**\n     * Writes a long value to the given buffer in LEB128 ZigZag encoded format\n     * (negative numbers not supported)\n     * @param buffer the buffer to write to\n     * @param value  the value to write to the buffer\n     */\n    ZigZagEncoding.encode = function (buffer, value) {\n        if (value >= 0) {\n            value = value * 2;\n        }\n        else {\n            value = -value * 2 - 1;\n        }\n        if (value < TWO_POW_7) {\n            buffer.put(value);\n        }\n        else {\n            buffer.put(value | 0x80);\n            if (value < TWO_POW_14) {\n                buffer.put(floor(value / TWO_POW_7));\n            }\n            else {\n                buffer.put(floor(value / TWO_POW_7) | 0x80);\n                if (value < TWO_POW_21) {\n                    buffer.put(floor(value / TWO_POW_14));\n                }\n                else {\n                    buffer.put(floor(value / TWO_POW_14) | 0x80);\n                    if (value < TWO_POW_28) {\n                        buffer.put(floor(value / TWO_POW_21));\n                    }\n                    else {\n                        buffer.put(floor(value / TWO_POW_21) | 0x80);\n                        if (value < TWO_POW_35) {\n                            buffer.put(floor(value / TWO_POW_28));\n                        }\n                        else {\n                            buffer.put(floor(value / TWO_POW_28) | 0x80);\n                            if (value < TWO_POW_42) {\n                                buffer.put(floor(value / TWO_POW_35));\n                            }\n                            else {\n                                buffer.put(floor(value / TWO_POW_35) | 0x80);\n                                if (value < TWO_POW_49) {\n                                    buffer.put(floor(value / TWO_POW_42));\n                                }\n                                else {\n                                    buffer.put(floor(value / TWO_POW_42) | 0x80);\n                                    if (value < TWO_POW_56) {\n                                        buffer.put(floor(value / TWO_POW_49));\n                                    }\n                                    else {\n                                        // should not happen\n                                        buffer.put(floor(value / TWO_POW_49) + 0x80);\n                                        buffer.put(floor(value / TWO_POW_56));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Read an LEB128-64b9B ZigZag encoded long value from the given buffer\n     * (negative numbers not supported)\n     * @param buffer the buffer to read from\n     * @return the value read from the buffer\n     */\n    ZigZagEncoding.decode = function (buffer) {\n        var v = buffer.get();\n        var value = v & 0x7f;\n        if ((v & 0x80) != 0) {\n            v = buffer.get();\n            value += (v & 0x7f) * TWO_POW_7;\n            if ((v & 0x80) != 0) {\n                v = buffer.get();\n                value += (v & 0x7f) * TWO_POW_14;\n                if ((v & 0x80) != 0) {\n                    v = buffer.get();\n                    value += (v & 0x7f) * TWO_POW_21;\n                    if ((v & 0x80) != 0) {\n                        v = buffer.get();\n                        value += (v & 0x7f) * TWO_POW_28;\n                        if ((v & 0x80) != 0) {\n                            v = buffer.get();\n                            value += (v & 0x7f) * TWO_POW_35;\n                            if ((v & 0x80) != 0) {\n                                v = buffer.get();\n                                value += (v & 0x7f) * TWO_POW_42;\n                                if ((v & 0x80) != 0) {\n                                    v = buffer.get();\n                                    value += (v & 0x7f) * TWO_POW_49;\n                                    if ((v & 0x80) != 0) {\n                                        v = buffer.get();\n                                        value += (v & 0x7f) * TWO_POW_56;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (value % 2 === 0) {\n            value = value / 2;\n        }\n        else {\n            value = -(value + 1) / 2;\n        }\n        return value;\n    };\n    return ZigZagEncoding;\n}());\nexports.default = ZigZagEncoding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ZigZagEncoding.ts\n// module id = 21\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\nexports.ByteBuffer = ByteBuffer_1.default;\nvar Int8Histogram_1 = require(\"./Int8Histogram\");\nexports.Int8Histogram = Int8Histogram_1.default;\nvar Int16Histogram_1 = require(\"./Int16Histogram\");\nexports.Int16Histogram = Int16Histogram_1.default;\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\nexports.Int32Histogram = Int32Histogram_1.default;\nvar Float64Histogram_1 = require(\"./Float64Histogram\");\nexports.Float64Histogram = Float64Histogram_1.default;\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nexports.AbstractHistogram = AbstractHistogram_1.default;\nexports.Histogram = AbstractHistogram_1.default;\nvar HistogramLogReader_1 = require(\"./HistogramLogReader\");\nexports.HistogramLogReader = HistogramLogReader_1.default;\nexports.listTags = HistogramLogReader_1.listTags;\nvar HistogramLogWriter_1 = require(\"./HistogramLogWriter\");\nexports.HistogramLogWriter = HistogramLogWriter_1.default;\nvar encoding_1 = require(\"./encoding\");\nexports.decodeFromCompressedBase64 = encoding_1.decodeFromCompressedBase64;\nexports.encodeIntoBase64String = encoding_1.encodeIntoBase64String;\nvar Recorder_1 = require(\"./Recorder\");\nexports.Recorder = Recorder_1.default;\nvar defaultRequest = {\n    bitBucketSize: 32,\n    autoResize: true,\n    lowestDiscernibleValue: 1,\n    highestTrackableValue: 2,\n    numberOfSignificantValueDigits: 3\n};\nexports.defaultRequest = defaultRequest;\nvar build = function (request) {\n    if (request === void 0) { request = defaultRequest; }\n    var parameters = Object.assign({}, defaultRequest, request);\n    var histogramConstr;\n    switch (parameters.bitBucketSize) {\n        case 8:\n            histogramConstr = Int8Histogram_1.default;\n            break;\n        case 16:\n            histogramConstr = Int16Histogram_1.default;\n            break;\n        case 32:\n            histogramConstr = Int32Histogram_1.default;\n            break;\n        default:\n            histogramConstr = Float64Histogram_1.default;\n    }\n    var histogram = new histogramConstr(parameters.lowestDiscernibleValue, parameters.highestTrackableValue, parameters.numberOfSignificantValueDigits);\n    histogram.autoResize = parameters.autoResize;\n    return histogram;\n};\nexports.build = build;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.ts\n// module id = 22\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ulp = function (x) { return Math.pow(2, Math.floor(Math.log2(x)) - 52); };\nexports.default = ulp;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ulp.ts\n// module id = 23\n// module chunks = 0"],"sourceRoot":""}