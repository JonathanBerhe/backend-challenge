{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 92823520ca7196cfdf7e","webpack:///./src/index.ts","webpack:///./src/ByteBuffer.ts","webpack:///./src/Int8Histogram.ts","webpack:///./src/AbstractHistogram.ts","webpack:///./src/AbstractHistogramBase.ts","webpack:///./src/EncodableHistogram.ts","webpack:///./src/RecordedValuesIterator.ts","webpack:///./src/AbstractHistogramIterator.ts","webpack:///./src/HistogramIterationValue.ts","webpack:///./src/PercentileIterator.ts","webpack:///./src/formatters.ts","webpack:///./src/ulp.ts","webpack:///./src/Int16Histogram.ts","webpack:///./src/Int32Histogram.ts","webpack:///./src/Float64Histogram.ts","webpack:///./src/HistogramLogReader.ts","webpack:///./src/encoding.ts","webpack:///./src/AbstractHistogram.encoding.ts","webpack:///./src/ZigZagEncoding.ts","webpack:///external \"pako\"","webpack:///./~/base64-js/index.js","webpack:///./src/HistogramLogWriter.ts","webpack:///./src/Recorder.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACtCA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,0BAA0B;AACvD,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7DA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACvEA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACtFA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,SAAQ,6DAA6D;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD,oCAAoC;AAC5F,sDAAqD,iCAAiC;AACtF,uCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA4E,qDAAqD;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,iDAAiD;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA4E,qDAAqD;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,mFAAmF;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ,YAAY,0CAA0C,YAAY;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,wCAAwC;AAC/E;AACA;AACA;AACA;AACA;AACA,4BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;;;;;;;ACvvBA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACtDA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AClDA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC9FA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,8BAA6B,+CAA+C;AAC5E;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D,yBAAwB,mDAAmD;AAC3E;;;;;;;ACVA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACtFA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACtFA;AACA;AACA;AACA,WAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,0BAAyB,uDAAuD;AAChF;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,EAAC;AACD,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACtFA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,uBAAuB;AAClE,0CAAyC,oCAAoC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,yCAAwC,wCAAwC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,kCAAiC,0DAA0D,EAAE;AAC7F,+BAA8B,6DAA6D,EAAE;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1JA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,4CAA4C;AACjF,qDAAoD,oCAAoC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3BA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B,kDAAiD;AACjD,sEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9KA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,iBAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;ACjJA,iD;;;;;;ACAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA0C,UAAU;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACnHA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,2EAA2E;AACtH,0CAAyC,uEAAuE;AAChH,4CAA2C,0BAA0B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,cAAc;AAC5D;AACA;AACA,0DAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,KAAI,eAAe;AACnB,KAAI,2BAA2B;AAC/B,KAAI,+CAA+C;AACnD;AACA;AACA;AACA;AACA,oCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD,oCAAoC;AAC5F,gCAA+B,sBAAsB,6BAA6B,GAAG;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA,SAAQ,sCAAsC;AAC9C,SAAQ,mEAAmE;AAC3E,SAAQ,yBAAyB;AACjC;AACA,SAAQ;AACR,iDAAgD;AAChD,SAAQ,sCAAsC;AAC9C;AACA;AACA;AACA;AACA,iBAAgB;AAChB,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA;AACA,yBAAwB,sBAAsB;AAC9C;AACA,iBAAgB,mEAAmE;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD","file":"hdrhistogram.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"pako\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"hdr\", [\"pako\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"hdr\"] = factory(require(\"pako\"));\n\telse\n\t\troot[\"hdr\"] = factory(root[\"pako\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_20__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 92823520ca7196cfdf7e","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\nexports.ByteBuffer = ByteBuffer_1.default;\nvar Int8Histogram_1 = require(\"./Int8Histogram\");\nexports.Int8Histogram = Int8Histogram_1.default;\nvar Int16Histogram_1 = require(\"./Int16Histogram\");\nexports.Int16Histogram = Int16Histogram_1.default;\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\nexports.Int32Histogram = Int32Histogram_1.default;\nvar Float64Histogram_1 = require(\"./Float64Histogram\");\nexports.Float64Histogram = Float64Histogram_1.default;\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nexports.AbstractHistogram = AbstractHistogram_1.default;\nexports.Histogram = AbstractHistogram_1.default;\nvar HistogramLogReader_1 = require(\"./HistogramLogReader\");\nexports.HistogramLogReader = HistogramLogReader_1.default;\nexports.listTags = HistogramLogReader_1.listTags;\nvar HistogramLogWriter_1 = require(\"./HistogramLogWriter\");\nexports.HistogramLogWriter = HistogramLogWriter_1.default;\nvar encoding_1 = require(\"./encoding\");\nexports.decodeFromCompressedBase64 = encoding_1.decodeFromCompressedBase64;\nexports.encodeIntoBase64String = encoding_1.encodeIntoBase64String;\nvar Recorder_1 = require(\"./Recorder\");\nexports.Recorder = Recorder_1.default;\nvar defaultRequest = {\n    bitBucketSize: 32,\n    autoResize: true,\n    lowestDiscernibleValue: 1,\n    highestTrackableValue: 2,\n    numberOfSignificantValueDigits: 3\n};\nexports.defaultRequest = defaultRequest;\nvar build = function (request) {\n    if (request === void 0) { request = defaultRequest; }\n    var parameters = Object.assign({}, defaultRequest, request);\n    var histogramConstr;\n    switch (parameters.bitBucketSize) {\n        case 8:\n            histogramConstr = Int8Histogram_1.default;\n            break;\n        case 16:\n            histogramConstr = Int16Histogram_1.default;\n            break;\n        case 32:\n            histogramConstr = Int32Histogram_1.default;\n            break;\n        default:\n            histogramConstr = Float64Histogram_1.default;\n    }\n    var histogram = new histogramConstr(parameters.lowestDiscernibleValue, parameters.highestTrackableValue, parameters.numberOfSignificantValueDigits);\n    histogram.autoResize = parameters.autoResize;\n    return histogram;\n};\nexports.build = build;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.ts\n// module id = 1\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pow = Math.pow, floor = Math.floor;\nvar TWO_POW_32 = pow(2, 32);\n/**\n * Mimic Java's ByteBufffer with big endian order\n */\nvar ByteBuffer = /** @class */ (function () {\n    function ByteBuffer(data) {\n        this.position = 0;\n        this.data = data;\n        this.int32ArrayForConvert = new Uint32Array(1);\n        this.int8ArrayForConvert = new Uint8Array(this.int32ArrayForConvert.buffer);\n    }\n    ByteBuffer.allocate = function (size) {\n        if (size === void 0) { size = 16; }\n        return new ByteBuffer(new Uint8Array(size));\n    };\n    ByteBuffer.prototype.put = function (value) {\n        if (this.position === this.data.length) {\n            var oldArray = this.data;\n            this.data = new Uint8Array(this.data.length * 2);\n            this.data.set(oldArray);\n        }\n        this.data[this.position] = value;\n        this.position++;\n    };\n    ByteBuffer.prototype.putInt32 = function (value) {\n        if (this.data.length - this.position < 4) {\n            var oldArray = this.data;\n            this.data = new Uint8Array(this.data.length * 2 + 4);\n            this.data.set(oldArray);\n        }\n        this.int32ArrayForConvert[0] = value;\n        this.data.set(this.int8ArrayForConvert.reverse(), this.position);\n        this.position += 4;\n    };\n    ByteBuffer.prototype.putInt64 = function (value) {\n        this.putInt32(floor(value / TWO_POW_32));\n        this.putInt32(value);\n    };\n    ByteBuffer.prototype.putArray = function (array) {\n        if (this.data.length - this.position < array.byteLength) {\n            var oldArray = this.data;\n            this.data = new Uint8Array(this.position + array.byteLength);\n            this.data.set(oldArray);\n        }\n        this.data.set(array, this.position);\n        this.position += array.byteLength;\n    };\n    ByteBuffer.prototype.get = function () {\n        var value = this.data[this.position];\n        this.position++;\n        return value;\n    };\n    ByteBuffer.prototype.getInt32 = function () {\n        this.int8ArrayForConvert.set(this.data.slice(this.position, this.position + 4).reverse());\n        var value = this.int32ArrayForConvert[0];\n        this.position += 4;\n        return value;\n    };\n    ByteBuffer.prototype.getInt64 = function () {\n        var high = this.getInt32();\n        var low = this.getInt32();\n        return high * TWO_POW_32 + low;\n    };\n    ByteBuffer.prototype.resetPosition = function () {\n        this.position = 0;\n    };\n    return ByteBuffer;\n}());\nexports.default = ByteBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ByteBuffer.ts\n// module id = 2\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int8Histogram = /** @class */ (function (_super) {\n    __extends(Int8Histogram, _super);\n    function Int8Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Uint8Array(_this.countsArrayLength);\n        return _this;\n    }\n    Int8Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Int8Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int8Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int8Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Int8Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Uint8Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Int8Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Int8Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Int8Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Int8Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Int8Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Int8Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Int8Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + this.counts.length;\n    };\n    Int8Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Int8Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Int8Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Int8Histogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int8Histogram.ts\n// module id = 3\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\nvar RecordedValuesIterator_1 = require(\"./RecordedValuesIterator\");\nvar PercentileIterator_1 = require(\"./PercentileIterator\");\nvar formatters_1 = require(\"./formatters\");\nvar ulp_1 = require(\"./ulp\");\nvar pow = Math.pow, floor = Math.floor, ceil = Math.ceil, log2 = Math.log2, max = Math.max, min = Math.min;\nvar AbstractHistogram = /** @class */ (function (_super) {\n    __extends(AbstractHistogram, _super);\n    function AbstractHistogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this) || this;\n        _this.maxValue = 0;\n        _this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\n        // Verify argument validity\n        if (lowestDiscernibleValue < 1) {\n            throw new Error(\"lowestDiscernibleValue must be >= 1\");\n        }\n        if (highestTrackableValue < 2 * lowestDiscernibleValue) {\n            throw new Error(\"highestTrackableValue must be >= 2 * lowestDiscernibleValue\");\n        }\n        if (numberOfSignificantValueDigits < 0 ||\n            numberOfSignificantValueDigits > 5) {\n            throw new Error(\"numberOfSignificantValueDigits must be between 0 and 5\");\n        }\n        _this.identity = AbstractHistogramBase_1.AbstractHistogramBase.identityBuilder++;\n        _this.init(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, 1.0, 0);\n        return _this;\n    }\n    AbstractHistogram.prototype.updatedMaxValue = function (value) {\n        var internalValue = value + this.unitMagnitudeMask;\n        this.maxValue = internalValue;\n    };\n    AbstractHistogram.prototype.updateMinNonZeroValue = function (value) {\n        if (value <= this.unitMagnitudeMask) {\n            return;\n        }\n        var internalValue = floor(value / this.lowestDiscernibleValueRounded) *\n            this.lowestDiscernibleValueRounded;\n        this.minNonZeroValue = internalValue;\n    };\n    AbstractHistogram.prototype.resetMinNonZeroValue = function (minNonZeroValue) {\n        var internalValue = floor(minNonZeroValue / this.lowestDiscernibleValueRounded) *\n            this.lowestDiscernibleValueRounded;\n        this.minNonZeroValue =\n            minNonZeroValue === Number.MAX_SAFE_INTEGER\n                ? minNonZeroValue\n                : internalValue;\n    };\n    AbstractHistogram.prototype.init = function (lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits, integerToDoubleValueConversionRatio, normalizingIndexOffset) {\n        this.lowestDiscernibleValue = lowestDiscernibleValue;\n        this.highestTrackableValue = highestTrackableValue;\n        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\n        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\n        if (normalizingIndexOffset !== 0) {\n            this.setNormalizingIndexOffset(normalizingIndexOffset);\n        }\n        /*\n        * Given a 3 decimal point accuracy, the expectation is obviously for \"+/- 1 unit at 1000\". It also means that\n        * it's \"ok to be +/- 2 units at 2000\". The \"tricky\" thing is that it is NOT ok to be +/- 2 units at 1999. Only\n        * starting at 2000. So internally, we need to maintain single unit resolution to 2x 10^decimalPoints.\n        */\n        var largestValueWithSingleUnitResolution = 2 * floor(pow(10, numberOfSignificantValueDigits));\n        this.unitMagnitude = floor(log2(lowestDiscernibleValue));\n        this.lowestDiscernibleValueRounded = pow(2, this.unitMagnitude);\n        this.unitMagnitudeMask = this.lowestDiscernibleValueRounded - 1;\n        // We need to maintain power-of-two subBucketCount (for clean direct indexing) that is large enough to\n        // provide unit resolution to at least largestValueWithSingleUnitResolution. So figure out\n        // largestValueWithSingleUnitResolution's nearest power-of-two (rounded up), and use that:\n        var subBucketCountMagnitude = ceil(log2(largestValueWithSingleUnitResolution));\n        this.subBucketHalfCountMagnitude =\n            (subBucketCountMagnitude > 1 ? subBucketCountMagnitude : 1) - 1;\n        this.subBucketCount = pow(2, this.subBucketHalfCountMagnitude + 1);\n        this.subBucketHalfCount = this.subBucketCount / 2;\n        this.subBucketMask =\n            (floor(this.subBucketCount) - 1) * pow(2, this.unitMagnitude);\n        this.establishSize(highestTrackableValue);\n        this.leadingZeroCountBase =\n            53 - this.unitMagnitude - this.subBucketHalfCountMagnitude - 1;\n        this.percentileIterator = new PercentileIterator_1.default(this, 1);\n        this.recordedValuesIterator = new RecordedValuesIterator_1.default(this);\n    };\n    /**\n     * The buckets (each of which has subBucketCount sub-buckets, here assumed to be 2048 as an example) overlap:\n     *\n     * <pre>\n     * The 0'th bucket covers from 0...2047 in multiples of 1, using all 2048 sub-buckets\n     * The 1'th bucket covers from 2048..4097 in multiples of 2, using only the top 1024 sub-buckets\n     * The 2'th bucket covers from 4096..8191 in multiple of 4, using only the top 1024 sub-buckets\n     * ...\n     * </pre>\n     *\n     * Bucket 0 is \"special\" here. It is the only one that has 2048 entries. All the rest have 1024 entries (because\n     * their bottom half overlaps with and is already covered by the all of the previous buckets put together). In other\n     * words, the k'th bucket could represent 0 * 2^k to 2048 * 2^k in 2048 buckets with 2^k precision, but the midpoint\n     * of 1024 * 2^k = 2048 * 2^(k-1) = the k-1'th bucket's end, so we would use the previous bucket for those lower\n     * values as it has better precision.\n     */\n    AbstractHistogram.prototype.establishSize = function (newHighestTrackableValue) {\n        // establish counts array length:\n        this.countsArrayLength = this.determineArrayLengthNeeded(newHighestTrackableValue);\n        // establish exponent range needed to support the trackable value with no overflow:\n        this.bucketCount = this.getBucketsNeededToCoverValue(newHighestTrackableValue);\n        // establish the new highest trackable value:\n        this.highestTrackableValue = newHighestTrackableValue;\n    };\n    AbstractHistogram.prototype.determineArrayLengthNeeded = function (highestTrackableValue) {\n        if (highestTrackableValue < 2 * this.lowestDiscernibleValue) {\n            throw new Error(\"highestTrackableValue (\" +\n                highestTrackableValue +\n                \") cannot be < (2 * lowestDiscernibleValue)\");\n        }\n        //determine counts array length needed:\n        var countsArrayLength = this.getLengthForNumberOfBuckets(this.getBucketsNeededToCoverValue(highestTrackableValue));\n        return countsArrayLength;\n    };\n    /**\n     * If we have N such that subBucketCount * 2^N > max value, we need storage for N+1 buckets, each with enough\n     * slots to hold the top half of the subBucketCount (the lower half is covered by previous buckets), and the +1\n     * being used for the lower half of the 0'th bucket. Or, equivalently, we need 1 more bucket to capture the max\n     * value if we consider the sub-bucket length to be halved.\n     */\n    AbstractHistogram.prototype.getLengthForNumberOfBuckets = function (numberOfBuckets) {\n        var lengthNeeded = (numberOfBuckets + 1) * (this.subBucketCount / 2);\n        return lengthNeeded;\n    };\n    AbstractHistogram.prototype.getBucketsNeededToCoverValue = function (value) {\n        // the k'th bucket can express from 0 * 2^k to subBucketCount * 2^k in units of 2^k\n        var smallestUntrackableValue = this.subBucketCount * pow(2, this.unitMagnitude);\n        // always have at least 1 bucket\n        var bucketsNeeded = 1;\n        while (smallestUntrackableValue <= value) {\n            if (smallestUntrackableValue > Number.MAX_SAFE_INTEGER / 2) {\n                // TODO check array max size in JavaScript\n                // next shift will overflow, meaning that bucket could represent values up to ones greater than\n                // Number.MAX_SAFE_INTEGER, so it's the last bucket\n                return bucketsNeeded + 1;\n            }\n            smallestUntrackableValue = smallestUntrackableValue * 2;\n            bucketsNeeded++;\n        }\n        return bucketsNeeded;\n    };\n    /**\n     * Record a value in the histogram\n     *\n     * @param value The value to be recorded\n     * @throws may throw Error if value is exceeds highestTrackableValue\n     */\n    AbstractHistogram.prototype.recordValue = function (value) {\n        this.recordSingleValue(value);\n    };\n    AbstractHistogram.prototype.recordSingleValue = function (value) {\n        var countsIndex = this.countsArrayIndex(value);\n        if (countsIndex >= this.countsArrayLength) {\n            this.handleRecordException(1, value);\n        }\n        else {\n            this.incrementCountAtIndex(countsIndex);\n        }\n        this.updateMinAndMax(value);\n        this.incrementTotalCount();\n    };\n    AbstractHistogram.prototype.handleRecordException = function (count, value) {\n        if (!this.autoResize) {\n            throw new Error(\"Value \" + value + \" is outside of histogram covered range\");\n        }\n        this.resize(value);\n        var countsIndex = this.countsArrayIndex(value);\n        this.addToCountAtIndex(countsIndex, count);\n        this.highestTrackableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\n    };\n    AbstractHistogram.prototype.countsArrayIndex = function (value) {\n        if (value < 0) {\n            throw new Error(\"Histogram recorded value cannot be negative.\");\n        }\n        var bucketIndex = this.getBucketIndex(value);\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n        return this.computeCountsArrayIndex(bucketIndex, subBucketIndex);\n    };\n    AbstractHistogram.prototype.computeCountsArrayIndex = function (bucketIndex, subBucketIndex) {\n        // TODO\n        //assert(subBucketIndex < subBucketCount);\n        //assert(bucketIndex == 0 || (subBucketIndex >= subBucketHalfCount));\n        // Calculate the index for the first entry that will be used in the bucket (halfway through subBucketCount).\n        // For bucketIndex 0, all subBucketCount entries may be used, but bucketBaseIndex is still set in the middle.\n        var bucketBaseIndex = (bucketIndex + 1) * pow(2, this.subBucketHalfCountMagnitude);\n        // Calculate the offset in the bucket. This subtraction will result in a positive value in all buckets except\n        // the 0th bucket (since a value in that bucket may be less than half the bucket's 0 to subBucketCount range).\n        // However, this works out since we give bucket 0 twice as much space.\n        var offsetInBucket = subBucketIndex - this.subBucketHalfCount;\n        // The following is the equivalent of ((subBucketIndex  - subBucketHalfCount) + bucketBaseIndex;\n        return bucketBaseIndex + offsetInBucket;\n    };\n    /**\n     * @return the lowest (and therefore highest precision) bucket index that can represent the value\n     */\n    AbstractHistogram.prototype.getBucketIndex = function (value) {\n        // Calculates the number of powers of two by which the value is greater than the biggest value that fits in\n        // bucket 0. This is the bucket index since each successive bucket can hold a value 2x greater.\n        // The mask maps small values to bucket 0.\n        // return this.leadingZeroCountBase - Long.numberOfLeadingZeros(value | subBucketMask);\n        return max(floor(log2(value)) -\n            this.subBucketHalfCountMagnitude -\n            this.unitMagnitude, 0);\n    };\n    AbstractHistogram.prototype.getSubBucketIndex = function (value, bucketIndex) {\n        // For bucketIndex 0, this is just value, so it may be anywhere in 0 to subBucketCount.\n        // For other bucketIndex, this will always end up in the top half of subBucketCount: assume that for some bucket\n        // k > 0, this calculation will yield a value in the bottom half of 0 to subBucketCount. Then, because of how\n        // buckets overlap, it would have also been in the top half of bucket k-1, and therefore would have\n        // returned k-1 in getBucketIndex(). Since we would then shift it one fewer bits here, it would be twice as big,\n        // and therefore in the top half of subBucketCount.\n        return floor(value / pow(2, bucketIndex + this.unitMagnitude));\n    };\n    AbstractHistogram.prototype.updateMinAndMax = function (value) {\n        if (value > this.maxValue) {\n            this.updatedMaxValue(value);\n        }\n        if (value < this.minNonZeroValue && value !== 0) {\n            this.updateMinNonZeroValue(value);\n        }\n    };\n    /**\n     * Get the value at a given percentile.\n     * When the given percentile is &gt; 0.0, the value returned is the value that the given\n     * percentage of the overall recorded value entries in the histogram are either smaller than\n     * or equivalent to. When the given percentile is 0.0, the value returned is the value that all value\n     * entries in the histogram are either larger than or equivalent to.\n     * <p>\n     * Note that two values are \"equivalent\" in this statement if\n     * {@link org.HdrHistogram.AbstractHistogram#valuesAreEquivalent} would return true.\n     *\n     * @param percentile  The percentile for which to return the associated value\n     * @return The value that the given percentage of the overall recorded value entries in the\n     * histogram are either smaller than or equivalent to. When the percentile is 0.0, returns the\n     * value that all value entries in the histogram are either larger than or equivalent to.\n     */\n    AbstractHistogram.prototype.getValueAtPercentile = function (percentile) {\n        var requestedPercentile = min(percentile, 100); // Truncate down to 100%\n        // round count up to nearest integer, to ensure that the largest value that the requested percentile\n        // of overall recorded values is actually included. However, this must be done with care:\n        //\n        // First, Compute fp value for count at the requested percentile. Note that fp result end up\n        // being 1 ulp larger than the correct integer count for this percentile:\n        var fpCountAtPercentile = requestedPercentile / 100.0 * this.getTotalCount();\n        // Next, round up, but make sure to prevent <= 1 ulp inaccurancies in the above fp math from\n        // making us skip a count:\n        var countAtPercentile = max(ceil(fpCountAtPercentile - ulp_1.default(fpCountAtPercentile)), // round up\n        1 // Make sure we at least reach the first recorded entry\n        );\n        var totalToCurrentIndex = 0;\n        for (var i = 0; i < this.countsArrayLength; i++) {\n            totalToCurrentIndex += this.getCountAtIndex(i);\n            if (totalToCurrentIndex >= countAtPercentile) {\n                var valueAtIndex = this.valueFromIndex(i);\n                return percentile === 0.0\n                    ? this.lowestEquivalentValue(valueAtIndex)\n                    : this.highestEquivalentValue(valueAtIndex);\n            }\n        }\n        return 0;\n    };\n    AbstractHistogram.prototype.valueFromIndexes = function (bucketIndex, subBucketIndex) {\n        return subBucketIndex * pow(2, bucketIndex + this.unitMagnitude);\n    };\n    AbstractHistogram.prototype.valueFromIndex = function (index) {\n        var bucketIndex = floor(index / this.subBucketHalfCount) - 1;\n        var subBucketIndex = index % this.subBucketHalfCount + this.subBucketHalfCount;\n        if (bucketIndex < 0) {\n            subBucketIndex -= this.subBucketHalfCount;\n            bucketIndex = 0;\n        }\n        return this.valueFromIndexes(bucketIndex, subBucketIndex);\n    };\n    /**\n     * Get the lowest value that is equivalent to the given value within the histogram's resolution.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The lowest value that is equivalent to the given value within the histogram's resolution.\n     */\n    AbstractHistogram.prototype.lowestEquivalentValue = function (value) {\n        var bucketIndex = this.getBucketIndex(value);\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n        var thisValueBaseLevel = this.valueFromIndexes(bucketIndex, subBucketIndex);\n        return thisValueBaseLevel;\n    };\n    /**\n     * Get the highest value that is equivalent to the given value within the histogram's resolution.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The highest value that is equivalent to the given value within the histogram's resolution.\n     */\n    AbstractHistogram.prototype.highestEquivalentValue = function (value) {\n        return this.nextNonEquivalentValue(value) - 1;\n    };\n    /**\n     * Get the next value that is not equivalent to the given value within the histogram's resolution.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The next value that is not equivalent to the given value within the histogram's resolution.\n     */\n    AbstractHistogram.prototype.nextNonEquivalentValue = function (value) {\n        return (this.lowestEquivalentValue(value) + this.sizeOfEquivalentValueRange(value));\n    };\n    /**\n     * Get the size (in value units) of the range of values that are equivalent to the given value within the\n     * histogram's resolution. Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The size of the range of values equivalent to the given value.\n     */\n    AbstractHistogram.prototype.sizeOfEquivalentValueRange = function (value) {\n        var bucketIndex = this.getBucketIndex(value);\n        var subBucketIndex = this.getSubBucketIndex(value, bucketIndex);\n        var distanceToNextValue = pow(2, this.unitMagnitude +\n            (subBucketIndex >= this.subBucketCount ? bucketIndex + 1 : bucketIndex));\n        return distanceToNextValue;\n    };\n    /**\n     * Get a value that lies in the middle (rounded up) of the range of values equivalent the given value.\n     * Where \"equivalent\" means that value samples recorded for any two\n     * equivalent values are counted in a common total count.\n     *\n     * @param value The given value\n     * @return The value lies in the middle (rounded up) of the range of values equivalent the given value.\n     */\n    AbstractHistogram.prototype.medianEquivalentValue = function (value) {\n        return (this.lowestEquivalentValue(value) +\n            floor(this.sizeOfEquivalentValueRange(value) / 2));\n    };\n    /**\n     * Get the computed mean value of all recorded values in the histogram\n     *\n     * @return the mean value (in value units) of the histogram data\n     */\n    AbstractHistogram.prototype.getMean = function () {\n        if (this.getTotalCount() === 0) {\n            return 0;\n        }\n        this.recordedValuesIterator.reset();\n        var totalValue = 0;\n        while (this.recordedValuesIterator.hasNext()) {\n            var iterationValue = this.recordedValuesIterator.next();\n            totalValue +=\n                this.medianEquivalentValue(iterationValue.valueIteratedTo) *\n                    iterationValue.countAtValueIteratedTo;\n        }\n        return totalValue * 1.0 / this.getTotalCount();\n    };\n    /**\n     * Get the computed standard deviation of all recorded values in the histogram\n     *\n     * @return the standard deviation (in value units) of the histogram data\n     */\n    AbstractHistogram.prototype.getStdDeviation = function () {\n        if (this.getTotalCount() === 0) {\n            return 0;\n        }\n        var mean = this.getMean();\n        var geometric_deviation_total = 0.0;\n        this.recordedValuesIterator.reset();\n        while (this.recordedValuesIterator.hasNext()) {\n            var iterationValue = this.recordedValuesIterator.next();\n            var deviation = this.medianEquivalentValue(iterationValue.valueIteratedTo) - mean;\n            geometric_deviation_total +=\n                deviation * deviation * iterationValue.countAddedInThisIterationStep;\n        }\n        var std_deviation = Math.sqrt(geometric_deviation_total / this.getTotalCount());\n        return std_deviation;\n    };\n    /**\n     * Produce textual representation of the value distribution of histogram data by percentile. The distribution is\n     * output with exponentially increasing resolution, with each exponentially decreasing half-distance containing\n     * <i>dumpTicksPerHalf</i> percentile reporting tick points.\n     *\n     * @param printStream    Stream into which the distribution will be output\n     * <p>\n     * @param percentileTicksPerHalfDistance  The number of reporting points per exponentially decreasing half-distance\n     * <p>\n     * @param outputValueUnitScalingRatio    The scaling factor by which to divide histogram recorded values units in\n     *                                     output\n     * @param useCsvFormat  Output in CSV format if true. Otherwise use plain text form.\n     */\n    AbstractHistogram.prototype.outputPercentileDistribution = function (percentileTicksPerHalfDistance, outputValueUnitScalingRatio, useCsvFormat) {\n        if (percentileTicksPerHalfDistance === void 0) { percentileTicksPerHalfDistance = 5; }\n        if (outputValueUnitScalingRatio === void 0) { outputValueUnitScalingRatio = 1; }\n        if (useCsvFormat === void 0) { useCsvFormat = false; }\n        var result = \"\";\n        if (useCsvFormat) {\n            result += '\"Value\",\"Percentile\",\"TotalCount\",\"1/(1-Percentile)\"\\n';\n        }\n        else {\n            result += \"       Value     Percentile TotalCount 1/(1-Percentile)\\n\\n\";\n        }\n        var iterator = this.percentileIterator;\n        iterator.reset(percentileTicksPerHalfDistance);\n        var lineFormatter;\n        var lastLineFormatter;\n        if (useCsvFormat) {\n            var valueFormatter_1 = formatters_1.floatFormatter(0, this.numberOfSignificantValueDigits);\n            var percentileFormatter_1 = formatters_1.floatFormatter(0, 12);\n            var lastFormatter_1 = formatters_1.floatFormatter(0, 2);\n            lineFormatter = function (iterationValue) {\n                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \",\" +\n                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\n                    \",\" +\n                    iterationValue.totalCountToThisValue +\n                    \",\" +\n                    lastFormatter_1(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\n                    \"\\n\";\n            };\n            lastLineFormatter = function (iterationValue) {\n                return valueFormatter_1(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \",\" +\n                    percentileFormatter_1(iterationValue.percentileLevelIteratedTo / 100) +\n                    \",\" +\n                    iterationValue.totalCountToThisValue +\n                    \",Infinity\\n\";\n            };\n        }\n        else {\n            var valueFormatter_2 = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\n            var percentileFormatter_2 = formatters_1.floatFormatter(2, 12);\n            var totalCountFormatter_1 = formatters_1.integerFormatter(10);\n            var lastFormatter_2 = formatters_1.floatFormatter(14, 2);\n            lineFormatter = function (iterationValue) {\n                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \" \" +\n                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\n                    \" \" +\n                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\n                    \" \" +\n                    lastFormatter_2(1 / (1 - iterationValue.percentileLevelIteratedTo / 100)) +\n                    \"\\n\";\n            };\n            lastLineFormatter = function (iterationValue) {\n                return valueFormatter_2(iterationValue.valueIteratedTo / outputValueUnitScalingRatio) +\n                    \" \" +\n                    percentileFormatter_2(iterationValue.percentileLevelIteratedTo / 100) +\n                    \" \" +\n                    totalCountFormatter_1(iterationValue.totalCountToThisValue) +\n                    \"\\n\";\n            };\n        }\n        while (iterator.hasNext()) {\n            var iterationValue = iterator.next();\n            if (iterationValue.percentileLevelIteratedTo < 100) {\n                result += lineFormatter(iterationValue);\n            }\n            else {\n                result += lastLineFormatter(iterationValue);\n            }\n        }\n        if (!useCsvFormat) {\n            // Calculate and output mean and std. deviation.\n            // Note: mean/std. deviation numbers are very often completely irrelevant when\n            // data is extremely non-normal in distribution (e.g. in cases of strong multi-modal\n            // response time distribution associated with GC pauses). However, reporting these numbers\n            // can be very useful for contrasting with the detailed percentile distribution\n            // reported by outputPercentileDistribution(). It is not at all surprising to find\n            // percentile distributions where results fall many tens or even hundreds of standard\n            // deviations away from the mean - such results simply indicate that the data sampled\n            // exhibits a very non-normal distribution, highlighting situations for which the std.\n            // deviation metric is a useless indicator.\n            //\n            var formatter = formatters_1.floatFormatter(12, this.numberOfSignificantValueDigits);\n            var mean = formatter(this.getMean() / outputValueUnitScalingRatio);\n            var std_deviation = formatter(this.getStdDeviation() / outputValueUnitScalingRatio);\n            var max_1 = formatter(this.maxValue / outputValueUnitScalingRatio);\n            var intFormatter = formatters_1.integerFormatter(12);\n            var totalCount = intFormatter(this.getTotalCount());\n            var bucketCount = intFormatter(this.bucketCount);\n            var subBucketCount = intFormatter(this.subBucketCount);\n            result += \"#[Mean    = \" + mean + \", StdDeviation   = \" + std_deviation + \"]\\n#[Max     = \" + max_1 + \", Total count    = \" + totalCount + \"]\\n#[Buckets = \" + bucketCount + \", SubBuckets     = \" + subBucketCount + \"]\\n\";\n        }\n        return result;\n    };\n    /**\n     * Provide a (conservatively high) estimate of the Histogram's total footprint in bytes\n     *\n     * @return a (conservatively high) estimate of the Histogram's total footprint in bytes\n     */\n    AbstractHistogram.prototype.getEstimatedFootprintInBytes = function () {\n        return this._getEstimatedFootprintInBytes();\n    };\n    AbstractHistogram.prototype.recordSingleValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n        this.recordSingleValue(value);\n        if (expectedIntervalBetweenValueSamples <= 0) {\n            return;\n        }\n        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\n            this.recordSingleValue(missingValue);\n        }\n    };\n    AbstractHistogram.prototype.recordCountAtValue = function (count, value) {\n        var countsIndex = this.countsArrayIndex(value);\n        if (countsIndex >= this.countsArrayLength) {\n            this.handleRecordException(count, value);\n        }\n        else {\n            this.addToCountAtIndex(countsIndex, count);\n        }\n        this.updateMinAndMax(value);\n        this.addToTotalCount(count);\n    };\n    /**\n     * Record a value in the histogram (adding to the value's current count)\n     *\n     * @param value The value to be recorded\n     * @param count The number of occurrences of this value to record\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    AbstractHistogram.prototype.recordValueWithCount = function (value, count) {\n        this.recordCountAtValue(count, value);\n    };\n    /**\n     * Record a value in the histogram.\n     * <p>\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\n     * (down to the expectedIntervalBetweenValueSamples) value records.\n     * <p>\n     * Note: This is a at-recording correction method, as opposed to the post-recording correction method provided\n     * by {@link #copyCorrectedForCoordinatedOmission(long)}.\n     * The two methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\n     * for the same coordinated omission issue.\n     * <p>\n     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\n     * important.\n     *\n     * @param value The value to record\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n     *                                           auto-generated value records as appropriate if value is larger\n     *                                           than expectedIntervalBetweenValueSamples\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    AbstractHistogram.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n        this.recordSingleValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\n    };\n    AbstractHistogram.prototype.recordValueWithCountAndExpectedInterval = function (value, count, expectedIntervalBetweenValueSamples) {\n        this.recordCountAtValue(count, value);\n        if (expectedIntervalBetweenValueSamples <= 0) {\n            return;\n        }\n        for (var missingValue = value - expectedIntervalBetweenValueSamples; missingValue >= expectedIntervalBetweenValueSamples; missingValue -= expectedIntervalBetweenValueSamples) {\n            this.recordCountAtValue(count, missingValue);\n        }\n    };\n    /**\n     * Add the contents of another histogram to this one, while correcting the incoming data for coordinated omission.\n     * <p>\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n     * interval between value samples, the values added will include an auto-generated additional series of\n     * decreasingly-smaller (down to the expectedIntervalBetweenValueSamples) value records for each count found\n     * in the current histogram that is larger than the expectedIntervalBetweenValueSamples.\n     *\n     * Note: This is a post-recording correction method, as opposed to the at-recording correction method provided\n     * by {@link #recordValueWithExpectedInterval(long, long) recordValueWithExpectedInterval}. The two\n     * methods are mutually exclusive, and only one of the two should be be used on a given data set to correct\n     * for the same coordinated omission issue.\n     * by\n     * <p>\n     * See notes in the description of the Histogram calls for an illustration of why this corrective behavior is\n     * important.\n     *\n     * @param otherHistogram The other histogram. highestTrackableValue and largestValueWithSingleUnitResolution must match.\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n     *                                           auto-generated value records as appropriate if value is larger\n     *                                           than expectedIntervalBetweenValueSamples\n     * @throws ArrayIndexOutOfBoundsException (may throw) if values exceed highestTrackableValue\n     */\n    AbstractHistogram.prototype.addWhileCorrectingForCoordinatedOmission = function (otherHistogram, expectedIntervalBetweenValueSamples) {\n        var toHistogram = this;\n        var otherValues = new RecordedValuesIterator_1.default(otherHistogram);\n        while (otherValues.hasNext()) {\n            var v = otherValues.next();\n            toHistogram.recordValueWithCountAndExpectedInterval(v.valueIteratedTo, v.countAtValueIteratedTo, expectedIntervalBetweenValueSamples);\n        }\n    };\n    /**\n     * Add the contents of another histogram to this one.\n     * <p>\n     * As part of adding the contents, the start/end timestamp range of this histogram will be\n     * extended to include the start/end timestamp range of the other histogram.\n     *\n     * @param otherHistogram The other histogram.\n     * @throws (may throw) if values in fromHistogram's are\n     * higher than highestTrackableValue.\n     */\n    AbstractHistogram.prototype.add = function (otherHistogram) {\n        var highestRecordableValue = this.highestEquivalentValue(this.valueFromIndex(this.countsArrayLength - 1));\n        if (highestRecordableValue < otherHistogram.maxValue) {\n            if (!this.autoResize) {\n                throw new Error(\"The other histogram includes values that do not fit in this histogram's range.\");\n            }\n            this.resize(otherHistogram.maxValue);\n        }\n        if (this.bucketCount === otherHistogram.bucketCount &&\n            this.subBucketCount === otherHistogram.subBucketCount &&\n            this.unitMagnitude === otherHistogram.unitMagnitude) {\n            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\n            var observedOtherTotalCount = 0;\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n                var otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    this.addToCountAtIndex(i, otherCount);\n                    observedOtherTotalCount += otherCount;\n                }\n            }\n            this.setTotalCount(this.getTotalCount() + observedOtherTotalCount);\n            this.updatedMaxValue(max(this.maxValue, otherHistogram.maxValue));\n            this.updateMinNonZeroValue(min(this.minNonZeroValue, otherHistogram.minNonZeroValue));\n        }\n        else {\n            // Arrays are not a direct match (or the other could change on the fly in some valid way),\n            // so we can't just stream through and add them. Instead, go through the array and add each\n            // non-zero value found at it's proper value:\n            // Do max value first, to avoid max value updates on each iteration:\n            var otherMaxIndex = otherHistogram.countsArrayIndex(otherHistogram.maxValue);\n            var otherCount = otherHistogram.getCountAtIndex(otherMaxIndex);\n            this.recordCountAtValue(otherCount, otherHistogram.maxValue);\n            // Record the remaining values, up to but not including the max value:\n            for (var i = 0; i < otherMaxIndex; i++) {\n                otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    this.recordCountAtValue(otherCount, otherHistogram.valueFromIndex(i));\n                }\n            }\n        }\n        this.startTimeStampMsec = min(this.startTimeStampMsec, otherHistogram.startTimeStampMsec);\n        this.endTimeStampMsec = max(this.endTimeStampMsec, otherHistogram.endTimeStampMsec);\n    };\n    /**\n     * Get the count of recorded values at a specific value (to within the histogram resolution at the value level).\n     *\n     * @param value The value for which to provide the recorded count\n     * @return The total count of values recorded in the histogram within the value range that is\n     * {@literal >=} lowestEquivalentValue(<i>value</i>) and {@literal <=} highestEquivalentValue(<i>value</i>)\n     */\n    AbstractHistogram.prototype.getCountAtValue = function (value) {\n        var index = min(max(0, this.countsArrayIndex(value)), this.countsArrayLength - 1);\n        return this.getCountAtIndex(index);\n    };\n    /**\n     * Subtract the contents of another histogram from this one.\n     * <p>\n     * The start/end timestamps of this histogram will remain unchanged.\n     *\n     * @param otherHistogram The other histogram.\n     * @throws ArrayIndexOutOfBoundsException (may throw) if values in otherHistogram's are higher than highestTrackableValue.\n     *\n     */\n    AbstractHistogram.prototype.subtract = function (otherHistogram) {\n        var highestRecordableValue = this.valueFromIndex(this.countsArrayLength - 1);\n        if (highestRecordableValue < otherHistogram.maxValue) {\n            if (!this.autoResize) {\n                throw new Error(\"The other histogram includes values that do not fit in this histogram's range.\");\n            }\n            this.resize(otherHistogram.maxValue);\n        }\n        if (this.bucketCount === otherHistogram.bucketCount &&\n            this.subBucketCount === otherHistogram.subBucketCount &&\n            this.unitMagnitude === otherHistogram.unitMagnitude) {\n            // optim\n            // Counts arrays are of the same length and meaning, so we can just iterate and add directly:\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n                var otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    this.addToCountAtIndex(i, -otherCount);\n                }\n            }\n        }\n        else {\n            for (var i = 0; i < otherHistogram.countsArrayLength; i++) {\n                var otherCount = otherHistogram.getCountAtIndex(i);\n                if (otherCount > 0) {\n                    var otherValue = otherHistogram.valueFromIndex(i);\n                    if (this.getCountAtValue(otherValue) < otherCount) {\n                        throw new Error(\"otherHistogram count (\" +\n                            otherCount +\n                            \") at value \" +\n                            otherValue +\n                            \" is larger than this one's (\" +\n                            this.getCountAtValue(otherValue) +\n                            \")\");\n                    }\n                    this.recordCountAtValue(-otherCount, otherValue);\n                }\n            }\n        }\n        // With subtraction, the max and minNonZero values could have changed:\n        if (this.getCountAtValue(this.maxValue) <= 0 ||\n            this.getCountAtValue(this.minNonZeroValue) <= 0) {\n            this.establishInternalTackingValues();\n        }\n    };\n    AbstractHistogram.prototype.establishInternalTackingValues = function (lengthToCover) {\n        if (lengthToCover === void 0) { lengthToCover = this.countsArrayLength; }\n        this.maxValue = 0;\n        this.minNonZeroValue = Number.MAX_VALUE;\n        var maxIndex = -1;\n        var minNonZeroIndex = -1;\n        var observedTotalCount = 0;\n        for (var index = 0; index < lengthToCover; index++) {\n            var countAtIndex = this.getCountAtIndex(index);\n            if (countAtIndex > 0) {\n                observedTotalCount += countAtIndex;\n                maxIndex = index;\n                if (minNonZeroIndex == -1 && index != 0) {\n                    minNonZeroIndex = index;\n                }\n            }\n        }\n        if (maxIndex >= 0) {\n            this.updatedMaxValue(this.highestEquivalentValue(this.valueFromIndex(maxIndex)));\n        }\n        if (minNonZeroIndex >= 0) {\n            this.updateMinNonZeroValue(this.valueFromIndex(minNonZeroIndex));\n        }\n        this.setTotalCount(observedTotalCount);\n    };\n    AbstractHistogram.prototype.reset = function () {\n        this.clearCounts();\n        this.setTotalCount(0);\n        this.startTimeStampMsec = 0;\n        this.endTimeStampMsec = 0;\n        this.tag = AbstractHistogramBase_1.NO_TAG;\n        this.maxValue = 0;\n        this.minNonZeroValue = Number.MAX_SAFE_INTEGER;\n    };\n    return AbstractHistogram;\n}(AbstractHistogramBase_1.AbstractHistogramBase));\nexports.AbstractHistogram = AbstractHistogram;\nexports.default = AbstractHistogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogram.ts\n// module id = 4\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar EncodableHistogram_1 = require(\"./EncodableHistogram\");\nexports.NO_TAG = \"NO TAG\";\nvar AbstractHistogramBase = /** @class */ (function (_super) {\n    __extends(AbstractHistogramBase, _super);\n    //intermediateUncompressedByteBuffer : ByteBuffer = null;\n    //intermediateUncompressedByteArray : number[] = null;\n    /* useless ?\n    getIntegerToDoubleValueConversionRatio(): number {\n        return this.integerToDoubleValueConversionRatio;\n    }\n  \n    setIntegerToDoubleValueConversionRatio(integerToDoubleValueConversionRatio: number) {\n        this.integerToDoubleValueConversionRatio = integerToDoubleValueConversionRatio;\n    }*/\n    function AbstractHistogramBase() {\n        var _this = _super.call(this) || this;\n        _this.autoResize = false;\n        _this.startTimeStampMsec = Number.MAX_SAFE_INTEGER;\n        _this.endTimeStampMsec = 0;\n        _this.tag = exports.NO_TAG;\n        _this.integerToDoubleValueConversionRatio = 1.0;\n        _this.identity = 0;\n        _this.highestTrackableValue = 0;\n        _this.lowestDiscernibleValue = 0;\n        _this.numberOfSignificantValueDigits = 0;\n        _this.bucketCount = 0;\n        _this.subBucketCount = 0;\n        _this.countsArrayLength = 0;\n        _this.wordSizeInBytes = 0;\n        return _this;\n    }\n    return AbstractHistogramBase;\n}(EncodableHistogram_1.EncodableHistogram));\nexports.AbstractHistogramBase = AbstractHistogramBase;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogramBase.ts\n// module id = 5\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EncodableHistogram = /** @class */ (function () {\n    function EncodableHistogram() {\n    }\n    return EncodableHistogram;\n}());\nexports.EncodableHistogram = EncodableHistogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/EncodableHistogram.ts\n// module id = 6\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractHistogramIterator_1 = require(\"./AbstractHistogramIterator\");\n/**\n * Used for iterating through all recorded histogram values using the finest granularity steps supported by the\n * underlying representation. The iteration steps through all non-zero recorded value counts, and terminates when\n * all recorded histogram values are exhausted.\n */\nvar RecordedValuesIterator = /** @class */ (function (_super) {\n    __extends(RecordedValuesIterator, _super);\n    /**\n     * @param histogram The histogram this iterator will operate on\n     */\n    function RecordedValuesIterator(histogram) {\n        var _this = _super.call(this) || this;\n        _this.doReset(histogram);\n        return _this;\n    }\n    /**\n     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\n     */\n    RecordedValuesIterator.prototype.reset = function () {\n        this.doReset(this.histogram);\n    };\n    RecordedValuesIterator.prototype.doReset = function (histogram) {\n        _super.prototype.resetIterator.call(this, histogram);\n        this.visitedIndex = -1;\n    };\n    RecordedValuesIterator.prototype.incrementIterationLevel = function () {\n        this.visitedIndex = this.currentIndex;\n    };\n    RecordedValuesIterator.prototype.reachedIterationLevel = function () {\n        var currentCount = this.histogram.getCountAtIndex(this.currentIndex);\n        return currentCount != 0 && this.visitedIndex !== this.currentIndex;\n    };\n    return RecordedValuesIterator;\n}(AbstractHistogramIterator_1.default));\nexports.default = RecordedValuesIterator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/RecordedValuesIterator.ts\n// module id = 7\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar HistogramIterationValue_1 = require(\"./HistogramIterationValue\");\n/**\n * Used for iterating through histogram values.\n */\nvar AbstractHistogramIterator /* implements Iterator<HistogramIterationValue> */ = /** @class */ (function () {\n    function AbstractHistogramIterator() {\n        this.currentIterationValue = new HistogramIterationValue_1.default();\n    }\n    AbstractHistogramIterator.prototype.resetIterator = function (histogram) {\n        this.histogram = histogram;\n        this.savedHistogramTotalRawCount = histogram.getTotalCount();\n        this.arrayTotalCount = histogram.getTotalCount();\n        this.currentIndex = 0;\n        this.currentValueAtIndex = 0;\n        this.nextValueAtIndex = Math.pow(2, histogram.unitMagnitude);\n        this.prevValueIteratedTo = 0;\n        this.totalCountToPrevIndex = 0;\n        this.totalCountToCurrentIndex = 0;\n        this.totalValueToCurrentIndex = 0;\n        this.countAtThisValue = 0;\n        this.freshSubBucket = true;\n        this.currentIterationValue.reset();\n    };\n    /**\n     * Returns true if the iteration has more elements. (In other words, returns true if next would return an\n     * element rather than throwing an exception.)\n     *\n     * @return true if the iterator has more elements.\n     */\n    AbstractHistogramIterator.prototype.hasNext = function () {\n        if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\n            throw \"Concurrent Modification Exception\";\n        }\n        return this.totalCountToCurrentIndex < this.arrayTotalCount;\n    };\n    /**\n     * Returns the next element in the iteration.\n     *\n     * @return the {@link HistogramIterationValue} associated with the next element in the iteration.\n     */\n    AbstractHistogramIterator.prototype.next = function () {\n        // Move through the sub buckets and buckets until we hit the next reporting level:\n        while (!this.exhaustedSubBuckets()) {\n            this.countAtThisValue = this.histogram.getCountAtIndex(this.currentIndex);\n            if (this.freshSubBucket) {\n                // Don't add unless we've incremented since last bucket...\n                this.totalCountToCurrentIndex += this.countAtThisValue;\n                this.totalValueToCurrentIndex +=\n                    this.countAtThisValue *\n                        this.histogram.highestEquivalentValue(this.currentValueAtIndex);\n                this.freshSubBucket = false;\n            }\n            if (this.reachedIterationLevel()) {\n                var valueIteratedTo = this.getValueIteratedTo();\n                Object.assign(this.currentIterationValue, {\n                    valueIteratedTo: valueIteratedTo,\n                    valueIteratedFrom: this.prevValueIteratedTo,\n                    countAtValueIteratedTo: this.countAtThisValue,\n                    countAddedInThisIterationStep: this.totalCountToCurrentIndex - this.totalCountToPrevIndex,\n                    totalCountToThisValue: this.totalCountToCurrentIndex,\n                    totalValueToThisValue: this.totalValueToCurrentIndex,\n                    percentile: 100 * this.totalCountToCurrentIndex / this.arrayTotalCount,\n                    percentileLevelIteratedTo: this.getPercentileIteratedTo()\n                });\n                this.prevValueIteratedTo = valueIteratedTo;\n                this.totalCountToPrevIndex = this.totalCountToCurrentIndex;\n                this.incrementIterationLevel();\n                if (this.histogram.getTotalCount() !== this.savedHistogramTotalRawCount) {\n                    throw new Error(\"Concurrent Modification Exception\");\n                }\n                return this.currentIterationValue;\n            }\n            this.incrementSubBucket();\n        }\n        throw new Error(\"Index Out Of Bounds Exception\");\n    };\n    AbstractHistogramIterator.prototype.getPercentileIteratedTo = function () {\n        return 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\n    };\n    AbstractHistogramIterator.prototype.getPercentileIteratedFrom = function () {\n        return 100 * this.totalCountToPrevIndex / this.arrayTotalCount;\n    };\n    AbstractHistogramIterator.prototype.getValueIteratedTo = function () {\n        return this.histogram.highestEquivalentValue(this.currentValueAtIndex);\n    };\n    AbstractHistogramIterator.prototype.exhaustedSubBuckets = function () {\n        return this.currentIndex >= this.histogram.countsArrayLength;\n    };\n    AbstractHistogramIterator.prototype.incrementSubBucket = function () {\n        this.freshSubBucket = true;\n        this.currentIndex++;\n        this.currentValueAtIndex = this.histogram.valueFromIndex(this.currentIndex);\n        this.nextValueAtIndex = this.histogram.valueFromIndex(this.currentIndex + 1);\n    };\n    return AbstractHistogramIterator;\n}());\nexports.default = AbstractHistogramIterator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogramIterator.ts\n// module id = 8\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Represents a value point iterated through in a Histogram, with associated stats.\n * <ul>\n * <li><b><code>valueIteratedTo</code></b> :<br> The actual value level that was iterated to by the iterator</li>\n * <li><b><code>prevValueIteratedTo</code></b> :<br> The actual value level that was iterated from by the iterator</li>\n * <li><b><code>countAtValueIteratedTo</code></b> :<br> The count of recorded values in the histogram that\n * exactly match this [lowestEquivalentValue(valueIteratedTo)...highestEquivalentValue(valueIteratedTo)] value\n * range.</li>\n * <li><b><code>countAddedInThisIterationStep</code></b> :<br> The count of recorded values in the histogram that\n * were added to the totalCountToThisValue (below) as a result on this iteration step. Since multiple iteration\n * steps may occur with overlapping equivalent value ranges, the count may be lower than the count found at\n * the value (e.g. multiple linear steps or percentile levels can occur within a single equivalent value range)</li>\n * <li><b><code>totalCountToThisValue</code></b> :<br> The total count of all recorded values in the histogram at\n * values equal or smaller than valueIteratedTo.</li>\n * <li><b><code>totalValueToThisValue</code></b> :<br> The sum of all recorded values in the histogram at values\n * equal or smaller than valueIteratedTo.</li>\n * <li><b><code>percentile</code></b> :<br> The percentile of recorded values in the histogram at values equal\n * or smaller than valueIteratedTo.</li>\n * <li><b><code>percentileLevelIteratedTo</code></b> :<br> The percentile level that the iterator returning this\n * HistogramIterationValue had iterated to. Generally, percentileLevelIteratedTo will be equal to or smaller than\n * percentile, but the same value point can contain multiple iteration levels for some iterators. E.g. a\n * PercentileIterator can stop multiple times in the exact same value point (if the count at that value covers a\n * range of multiple percentiles in the requested percentile iteration points).</li>\n * </ul>\n */\nvar HistogramIterationValue = /** @class */ (function () {\n    function HistogramIterationValue() {\n        this.reset();\n    }\n    HistogramIterationValue.prototype.reset = function () {\n        this.valueIteratedTo = 0;\n        this.valueIteratedFrom = 0;\n        this.countAtValueIteratedTo = 0;\n        this.countAddedInThisIterationStep = 0;\n        this.totalCountToThisValue = 0;\n        this.totalValueToThisValue = 0;\n        this.percentile = 0.0;\n        this.percentileLevelIteratedTo = 0.0;\n    };\n    return HistogramIterationValue;\n}());\nexports.default = HistogramIterationValue;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramIterationValue.ts\n// module id = 9\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractHistogramIterator_1 = require(\"./AbstractHistogramIterator\");\nvar pow = Math.pow, floor = Math.floor, log2 = Math.log2;\n/**\n * Used for iterating through histogram values according to percentile levels. The iteration is\n * performed in steps that start at 0% and reduce their distance to 100% according to the\n * <i>percentileTicksPerHalfDistance</i> parameter, ultimately reaching 100% when all recorded histogram\n * values are exhausted.\n */\nvar PercentileIterator = /** @class */ (function (_super) {\n    __extends(PercentileIterator, _super);\n    /**\n     * @param histogram The histogram this iterator will operate on\n     * @param percentileTicksPerHalfDistance The number of equal-sized iteration steps per half-distance to 100%.\n     */\n    function PercentileIterator(histogram, percentileTicksPerHalfDistance) {\n        var _this = _super.call(this) || this;\n        _this.percentileTicksPerHalfDistance = 0;\n        _this.percentileLevelToIterateTo = 0;\n        _this.percentileLevelToIterateFrom = 0;\n        _this.reachedLastRecordedValue = false;\n        _this.doReset(histogram, percentileTicksPerHalfDistance);\n        return _this;\n    }\n    /**\n     * Reset iterator for re-use in a fresh iteration over the same histogram data set.\n     *\n     * @param percentileTicksPerHalfDistance The number of iteration steps per half-distance to 100%.\n     */\n    PercentileIterator.prototype.reset = function (percentileTicksPerHalfDistance) {\n        this.doReset(this.histogram, percentileTicksPerHalfDistance);\n    };\n    PercentileIterator.prototype.doReset = function (histogram, percentileTicksPerHalfDistance) {\n        _super.prototype.resetIterator.call(this, histogram);\n        this.percentileTicksPerHalfDistance = percentileTicksPerHalfDistance;\n        this.percentileLevelToIterateTo = 0;\n        this.percentileLevelToIterateFrom = 0;\n        this.reachedLastRecordedValue = false;\n    };\n    PercentileIterator.prototype.hasNext = function () {\n        if (_super.prototype.hasNext.call(this))\n            return true;\n        if (!this.reachedLastRecordedValue && this.arrayTotalCount > 0) {\n            this.percentileLevelToIterateTo = 100;\n            this.reachedLastRecordedValue = true;\n            return true;\n        }\n        return false;\n    };\n    PercentileIterator.prototype.incrementIterationLevel = function () {\n        this.percentileLevelToIterateFrom = this.percentileLevelToIterateTo;\n        // The choice to maintain fixed-sized \"ticks\" in each half-distance to 100% [starting\n        // from 0%], as opposed to a \"tick\" size that varies with each interval, was made to\n        // make the steps easily comprehensible and readable to humans. The resulting percentile\n        // steps are much easier to browse through in a percentile distribution output, for example.\n        //\n        // We calculate the number of equal-sized \"ticks\" that the 0-100 range will be divided\n        // by at the current scale. The scale is detemined by the percentile level we are\n        // iterating to. The following math determines the tick size for the current scale,\n        // and maintain a fixed tick size for the remaining \"half the distance to 100%\"\n        // [from either 0% or from the previous half-distance]. When that half-distance is\n        // crossed, the scale changes and the tick size is effectively cut in half.\n        // percentileTicksPerHalfDistance = 5\n        // percentileReportingTicks = 10,\n        var percentileReportingTicks = this.percentileTicksPerHalfDistance *\n            pow(2, floor(log2(100 / (100 - this.percentileLevelToIterateTo))) + 1);\n        this.percentileLevelToIterateTo += 100 / percentileReportingTicks;\n    };\n    PercentileIterator.prototype.reachedIterationLevel = function () {\n        if (this.countAtThisValue === 0) {\n            return false;\n        }\n        var currentPercentile = 100 * this.totalCountToCurrentIndex / this.arrayTotalCount;\n        return currentPercentile >= this.percentileLevelToIterateTo;\n    };\n    PercentileIterator.prototype.getPercentileIteratedTo = function () {\n        return this.percentileLevelToIterateTo;\n    };\n    PercentileIterator.prototype.getPercentileIteratedFrom = function () {\n        return this.percentileLevelToIterateFrom;\n    };\n    return PercentileIterator;\n}(AbstractHistogramIterator_1.default));\nexports.default = PercentileIterator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/PercentileIterator.ts\n// module id = 10\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar leftPadding = function (size) {\n    return function (input) {\n        if (input.length < size) {\n            return \" \".repeat(size - input.length) + input;\n        }\n        return input;\n    };\n};\nexports.integerFormatter = function (size) {\n    var padding = leftPadding(size);\n    return function (integer) { return padding(\"\" + integer); };\n};\nexports.floatFormatter = function (size, fractionDigits) {\n    var numberFormatter = new Intl.NumberFormat(\"en-US\", {\n        maximumFractionDigits: fractionDigits,\n        minimumFractionDigits: fractionDigits,\n        useGrouping: false\n    });\n    var padding = leftPadding(size);\n    return function (float) { return padding(numberFormatter.format(float)); };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/formatters.ts\n// module id = 11\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ulp = function (x) { return Math.pow(2, Math.floor(Math.log2(x)) - 52); };\nexports.default = ulp;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ulp.ts\n// module id = 12\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int16Histogram = /** @class */ (function (_super) {\n    __extends(Int16Histogram, _super);\n    function Int16Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Uint16Array(_this.countsArrayLength);\n        return _this;\n    }\n    Int16Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Int16Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int16Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int16Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Int16Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Uint16Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Int16Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Int16Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Int16Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Int16Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Int16Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Int16Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Int16Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + 2 * this.counts.length;\n    };\n    Int16Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Int16Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Int16Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Int16Histogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int16Histogram.ts\n// module id = 13\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int32Histogram = /** @class */ (function (_super) {\n    __extends(Int32Histogram, _super);\n    function Int32Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Uint32Array(_this.countsArrayLength);\n        return _this;\n    }\n    Int32Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Int32Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int32Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Int32Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Int32Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Uint32Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Int32Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Int32Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Int32Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Int32Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Int32Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Int32Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Int32Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + 4 * this.counts.length;\n    };\n    Int32Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Int32Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Int32Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Int32Histogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Int32Histogram.ts\n// module id = 14\n// module chunks = 0","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Float64Histogram = /** @class */ (function (_super) {\n    __extends(Float64Histogram, _super);\n    function Float64Histogram(lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) {\n        var _this = _super.call(this, lowestDiscernibleValue, highestTrackableValue, numberOfSignificantValueDigits) || this;\n        _this.totalCount = 0;\n        _this.counts = new Float64Array(_this.countsArrayLength);\n        return _this;\n    }\n    Float64Histogram.prototype.clearCounts = function () {\n        this.counts.fill(0);\n    };\n    Float64Histogram.prototype.incrementCountAtIndex = function (index) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + 1;\n        if (newCount < 0) {\n            throw newCount + \" would overflow short integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Float64Histogram.prototype.addToCountAtIndex = function (index, value) {\n        var currentCount = this.counts[index];\n        var newCount = currentCount + value;\n        if (newCount < Number.MIN_SAFE_INTEGER ||\n            newCount > Number.MAX_SAFE_INTEGER) {\n            throw newCount + \" would overflow integer count\";\n        }\n        this.counts[index] = newCount;\n    };\n    Float64Histogram.prototype.setCountAtIndex = function (index, value) {\n        if (value < Number.MIN_SAFE_INTEGER || value > Number.MAX_SAFE_INTEGER) {\n            throw value + \" would overflow integer count\";\n        }\n        this.counts[index] = value;\n    };\n    Float64Histogram.prototype.resize = function (newHighestTrackableValue) {\n        this.establishSize(newHighestTrackableValue);\n        var newCounts = new Float64Array(this.countsArrayLength);\n        newCounts.set(this.counts);\n        this.counts = newCounts;\n    };\n    Float64Histogram.prototype.setNormalizingIndexOffset = function (normalizingIndexOffset) { };\n    Float64Histogram.prototype.incrementTotalCount = function () {\n        this.totalCount++;\n    };\n    Float64Histogram.prototype.addToTotalCount = function (value) {\n        this.totalCount += value;\n    };\n    Float64Histogram.prototype.setTotalCount = function (value) {\n        this.totalCount = value;\n    };\n    Float64Histogram.prototype.getTotalCount = function () {\n        return this.totalCount;\n    };\n    Float64Histogram.prototype.getCountAtIndex = function (index) {\n        return this.counts[index];\n    };\n    Float64Histogram.prototype._getEstimatedFootprintInBytes = function () {\n        return 512 + 8 * this.counts.length;\n    };\n    Float64Histogram.prototype.copyCorrectedForCoordinatedOmission = function (expectedIntervalBetweenValueSamples) {\n        var copy = new Float64Histogram(this.lowestDiscernibleValue, this.highestTrackableValue, this.numberOfSignificantValueDigits);\n        copy.addWhileCorrectingForCoordinatedOmission(this, expectedIntervalBetweenValueSamples);\n        return copy;\n    };\n    return Float64Histogram;\n}(AbstractHistogram_1.default));\nexports.default = Float64Histogram;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Float64Histogram.ts\n// module id = 15\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\nvar encoding_1 = require(\"./encoding\");\nvar TAG_PREFIX = \"Tag=\";\nvar TAG_PREFIX_LENGTH = \"Tag=\".length;\n/**\n * A histogram log reader.\n * <p>\n * Histogram logs are used to capture full fidelity, per-time-interval\n * histograms of a recorded value.\n * <p>\n * For example, a histogram log can be used to capture high fidelity\n * reaction-time logs for some measured system or subsystem component.\n * Such a log would capture a full reaction time histogram for each\n * logged interval, and could be used to later reconstruct a full\n * HdrHistogram of the measured reaction time behavior for any arbitrary\n * time range within the log, by adding [only] the relevant interval\n * histograms.\n * <h3>Histogram log format:</h3>\n * A histogram log file consists of text lines. Lines beginning with\n * the \"#\" character are optional and treated as comments. Lines\n * containing the legend (starting with \"Timestamp\") are also optional\n * and ignored in parsing the histogram log. All other lines must\n * be valid interval description lines. Text fields are delimited by\n * commas, spaces.\n * <p>\n * A valid interval description line contains an optional Tag=tagString\n * text field, followed by an interval description.\n * <p>\n * A valid interval description must contain exactly four text fields:\n * <ul>\n * <li>StartTimestamp: The first field must contain a number parse-able as a Double value,\n * representing the start timestamp of the interval in seconds.</li>\n * <li>intervalLength: The second field must contain a number parse-able as a Double value,\n * representing the length of the interval in seconds.</li>\n * <li>Interval_Max: The third field must contain a number parse-able as a Double value,\n * which generally represents the maximum value of the interval histogram.</li>\n * <li>Interval_Compressed_Histogram: The fourth field must contain a text field\n * parse-able as a Base64 text representation of a compressed HdrHistogram.</li>\n * </ul>\n * The log file may contain an optional indication of a starting time. Starting time\n * is indicated using a special comments starting with \"#[StartTime: \" and followed\n * by a number parse-able as a double, representing the start time (in seconds)\n * that may be added to timestamps in the file to determine an absolute\n * timestamp (e.g. since the epoch) for each interval.\n */\nvar HistogramLogReader = /** @class */ (function () {\n    function HistogramLogReader(logContent) {\n        this.lines = splitLines(logContent);\n        this.currentLineIndex = 0;\n    }\n    /**\n     * Read the next interval histogram from the log. Returns a Histogram object if\n     * an interval line was found, or null if not.\n     * <p>Upon encountering any unexpected format errors in reading the next interval\n     * from the file, this method will return a null.\n     * @return a DecodedInterval, or a null if no appropriate interval found\n     */\n    HistogramLogReader.prototype.nextIntervalHistogram = function (rangeStartTimeSec, rangeEndTimeSec) {\n        if (rangeStartTimeSec === void 0) { rangeStartTimeSec = 0; }\n        if (rangeEndTimeSec === void 0) { rangeEndTimeSec = Number.MAX_VALUE; }\n        while (this.currentLineIndex < this.lines.length) {\n            var currentLine = this.lines[this.currentLineIndex];\n            this.currentLineIndex++;\n            if (currentLine.startsWith(\"#[StartTime:\")) {\n                this.parseStartTimeFromLine(currentLine);\n            }\n            else if (currentLine.startsWith(\"#[BaseTime:\")) {\n                this.parseBaseTimeFromLine(currentLine);\n            }\n            else if (currentLine.startsWith(\"#\") ||\n                currentLine.startsWith('\"StartTimestamp\"')) {\n                // skip legend & meta data for now\n            }\n            else if (currentLine.includes(\",\")) {\n                var tokens = currentLine.split(\",\");\n                var firstToken = tokens[0];\n                var tag = void 0;\n                if (firstToken.startsWith(TAG_PREFIX)) {\n                    tag = firstToken.substring(TAG_PREFIX_LENGTH);\n                    tokens.shift();\n                }\n                else {\n                    tag = AbstractHistogramBase_1.NO_TAG;\n                }\n                var rawLogTimeStampInSec = tokens[0], rawIntervalLengthSec = tokens[1], base64Histogram = tokens[3];\n                var logTimeStampInSec = Number.parseFloat(rawLogTimeStampInSec);\n                if (!this.baseTimeSec) {\n                    // No explicit base time noted. Deduce from 1st observed time (compared to start time):\n                    if (logTimeStampInSec < this.startTimeSec - 365 * 24 * 3600.0) {\n                        // Criteria Note: if log timestamp is more than a year in the past (compared to\n                        // StartTime), we assume that timestamps in the log are not absolute\n                        this.baseTimeSec = this.startTimeSec;\n                    }\n                    else {\n                        // Timestamps are absolute\n                        this.baseTimeSec = 0.0;\n                    }\n                }\n                if (rangeEndTimeSec < logTimeStampInSec) {\n                    return null;\n                }\n                if (logTimeStampInSec < rangeStartTimeSec) {\n                    continue;\n                }\n                var histogram = encoding_1.decodeFromCompressedBase64(base64Histogram);\n                histogram.startTimeStampMsec =\n                    (this.baseTimeSec + logTimeStampInSec) * 1000;\n                var intervalLengthSec = Number.parseFloat(rawIntervalLengthSec);\n                histogram.endTimeStampMsec =\n                    (this.baseTimeSec + logTimeStampInSec + intervalLengthSec) * 1000;\n                histogram.tag = tag;\n                return histogram;\n            }\n        }\n        return null;\n    };\n    HistogramLogReader.prototype.parseStartTimeFromLine = function (line) {\n        this.startTimeSec = Number.parseFloat(line.split(\" \")[1]);\n    };\n    HistogramLogReader.prototype.parseBaseTimeFromLine = function (line) {\n        this.baseTimeSec = Number.parseFloat(line.split(\" \")[1]);\n    };\n    return HistogramLogReader;\n}());\nvar splitLines = function (logContent) { return logContent.split(/\\r\\n|\\r|\\n/g); };\nvar shouldIncludeNoTag = function (lines) {\n    return lines.find(function (line) {\n        return !line.startsWith(\"#\") &&\n            !line.startsWith('\"') &&\n            !line.startsWith(TAG_PREFIX) &&\n            line.includes(\",\");\n    });\n};\nexports.listTags = function (content) {\n    var lines = splitLines(content);\n    var tags = lines\n        .filter(function (line) { return line.includes(\",\") && line.startsWith(TAG_PREFIX); })\n        .map(function (line) { return line.substring(TAG_PREFIX_LENGTH, line.indexOf(\",\")); });\n    var tagsWithoutDuplicates = new Set(tags);\n    var result = Array.from(tagsWithoutDuplicates);\n    if (shouldIncludeNoTag(lines)) {\n        result.unshift(\"NO TAG\");\n    }\n    return result;\n};\nexports.default = HistogramLogReader;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramLogReader.ts\n// module id = 16\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\nrequire(\"./AbstractHistogram.encoding\");\nvar base64 = require(\"base64-js\");\nvar decodeFromCompressedBase64 = function (base64String, histogramConstr, minBarForHighestTrackableValue) {\n    if (histogramConstr === void 0) { histogramConstr = Int32Histogram_1.default; }\n    if (minBarForHighestTrackableValue === void 0) { minBarForHighestTrackableValue = 0; }\n    var buffer = new ByteBuffer_1.default(base64.toByteArray(base64String));\n    return AbstractHistogram_1.AbstractHistogram.decodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue);\n};\nexports.decodeFromCompressedBase64 = decodeFromCompressedBase64;\nvar encodeIntoBase64String = function (histogram, compressionLevel) {\n    var buffer = ByteBuffer_1.default.allocate();\n    var bufferSize = histogram.encodeIntoCompressedByteBuffer(buffer, compressionLevel);\n    var encodedBuffer = buffer.data.slice(0, bufferSize);\n    return base64.fromByteArray(encodedBuffer);\n};\nexports.encodeIntoBase64String = encodeIntoBase64String;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/encoding.ts\n// module id = 17\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nvar ByteBuffer_1 = require(\"./ByteBuffer\");\nvar AbstractHistogram_1 = require(\"./AbstractHistogram\");\nvar ZigZagEncoding_1 = require(\"./ZigZagEncoding\");\nvar max = Math.max;\nvar V2EncodingCookieBase = 0x1c849303;\nvar V2CompressedEncodingCookieBase = 0x1c849304;\nvar V2maxWordSizeInBytes = 9; // LEB128-64b9B + ZigZag require up to 9 bytes per word\nvar encodingCookie = V2EncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\nvar compressedEncodingCookie = V2CompressedEncodingCookieBase | 0x10; // LSBit of wordsize byte indicates TLZE Encoding\nfunction fillBufferFromCountsArray(self, buffer) {\n    var countsLimit = self.countsArrayIndex(self.maxValue) + 1;\n    var srcIndex = 0;\n    while (srcIndex < countsLimit) {\n        // V2 encoding format uses a ZigZag LEB128-64b9B encoded long. Positive values are counts,\n        // while negative values indicate a repeat zero counts.\n        var count = self.getCountAtIndex(srcIndex++);\n        if (count < 0) {\n            throw new Error(\"Cannot encode histogram containing negative counts (\" +\n                count +\n                \") at index \" +\n                srcIndex +\n                \", corresponding the value range [\" +\n                self.lowestEquivalentValue(self.valueFromIndex(srcIndex)) +\n                \",\" +\n                self.nextNonEquivalentValue(self.valueFromIndex(srcIndex)) +\n                \")\");\n        }\n        // Count trailing 0s (which follow this count):\n        var zerosCount = 0;\n        if (count == 0) {\n            zerosCount = 1;\n            while (srcIndex < countsLimit && self.getCountAtIndex(srcIndex) == 0) {\n                zerosCount++;\n                srcIndex++;\n            }\n        }\n        if (zerosCount > 1) {\n            ZigZagEncoding_1.default.encode(buffer, -zerosCount);\n        }\n        else {\n            ZigZagEncoding_1.default.encode(buffer, count);\n        }\n    }\n}\n/**\n * Encode this histogram into a ByteBuffer\n * @param buffer The buffer to encode into\n * @return The number of bytes written to the buffer\n */\nfunction encodeIntoByteBuffer(buffer) {\n    var self = this;\n    var initialPosition = buffer.position;\n    buffer.putInt32(encodingCookie);\n    buffer.putInt32(0); // Placeholder for payload length in bytes.\n    buffer.putInt32(1);\n    buffer.putInt32(self.numberOfSignificantValueDigits);\n    buffer.putInt64(self.lowestDiscernibleValue);\n    buffer.putInt64(self.highestTrackableValue);\n    buffer.putInt64(1);\n    var payloadStartPosition = buffer.position;\n    fillBufferFromCountsArray(self, buffer);\n    var backupIndex = buffer.position;\n    buffer.position = initialPosition + 4;\n    buffer.putInt32(backupIndex - payloadStartPosition); // Record the payload length\n    buffer.position = backupIndex;\n    return backupIndex - initialPosition;\n}\nexports.encodeIntoByteBuffer = encodeIntoByteBuffer;\nfunction fillCountsArrayFromSourceBuffer(self, sourceBuffer, lengthInBytes, wordSizeInBytes) {\n    if (wordSizeInBytes != 2 &&\n        wordSizeInBytes != 4 &&\n        wordSizeInBytes != 8 &&\n        wordSizeInBytes != V2maxWordSizeInBytes) {\n        throw new Error(\"word size must be 2, 4, 8, or V2maxWordSizeInBytes (\" +\n            V2maxWordSizeInBytes +\n            \") bytes\");\n    }\n    var dstIndex = 0;\n    var endPosition = sourceBuffer.position + lengthInBytes;\n    while (sourceBuffer.position < endPosition) {\n        var zerosCount = 0;\n        var count = ZigZagEncoding_1.default.decode(sourceBuffer);\n        if (count < 0) {\n            zerosCount = -count;\n            dstIndex += zerosCount; // No need to set zeros in array. Just skip them.\n        }\n        else {\n            self.setCountAtIndex(dstIndex++, count);\n        }\n    }\n    return dstIndex; // this is the destination length\n}\nfunction getCookieBase(cookie) {\n    return cookie & ~0xf0;\n}\nfunction getWordSizeInBytesFromCookie(cookie) {\n    if (getCookieBase(cookie) == V2EncodingCookieBase ||\n        getCookieBase(cookie) == V2CompressedEncodingCookieBase) {\n        return V2maxWordSizeInBytes;\n    }\n    var sizeByte = (cookie & 0xf0) >> 4;\n    return sizeByte & 0xe;\n}\nfunction doDecodeFromByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue) {\n    var cookie = buffer.getInt32();\n    var payloadLengthInBytes;\n    var numberOfSignificantValueDigits;\n    var lowestTrackableUnitValue;\n    var highestTrackableValue;\n    if (getCookieBase(cookie) === V2EncodingCookieBase) {\n        if (getWordSizeInBytesFromCookie(cookie) != V2maxWordSizeInBytes) {\n            throw new Error(\"The buffer does not contain a Histogram (no valid cookie found)\");\n        }\n        payloadLengthInBytes = buffer.getInt32();\n        buffer.getInt32(); // normalizingIndexOffset not used\n        numberOfSignificantValueDigits = buffer.getInt32();\n        lowestTrackableUnitValue = buffer.getInt64();\n        highestTrackableValue = buffer.getInt64();\n        buffer.getInt64(); // integerToDoubleValueConversionRatio not used\n    }\n    else {\n        throw new Error(\"The buffer does not contain a Histogram (no valid V2 encoding cookie found)\");\n    }\n    highestTrackableValue = max(highestTrackableValue, minBarForHighestTrackableValue);\n    var histogram = new histogramConstr(lowestTrackableUnitValue, highestTrackableValue, numberOfSignificantValueDigits);\n    var filledLength = fillCountsArrayFromSourceBuffer(histogram, buffer, payloadLengthInBytes, V2maxWordSizeInBytes);\n    histogram.establishInternalTackingValues(filledLength);\n    return histogram;\n}\nexports.doDecodeFromByteBuffer = doDecodeFromByteBuffer;\nfunction doDecodeFromCompressedByteBuffer(buffer, histogramConstr, minBarForHighestTrackableValue) {\n    var initialTargetPosition = buffer.position;\n    var cookie = buffer.getInt32();\n    if ((cookie & ~0xf0) !== V2CompressedEncodingCookieBase) {\n        throw new Error(\"Encoding not supported, only V2 is supported\");\n    }\n    var lengthOfCompressedContents = buffer.getInt32();\n    var pako = require(\"pako/lib/inflate\");\n    var uncompressedBuffer = pako.inflate(buffer.data.slice(initialTargetPosition + 8, initialTargetPosition + 8 + lengthOfCompressedContents));\n    return doDecodeFromByteBuffer(new ByteBuffer_1.default(uncompressedBuffer), histogramConstr, minBarForHighestTrackableValue);\n}\nexports.doDecodeFromCompressedByteBuffer = doDecodeFromCompressedByteBuffer;\n/**\n * Encode this histogram in compressed form into a byte array\n * @param targetBuffer The buffer to encode into\n * @return The number of bytes written to the array\n */\nfunction encodeIntoCompressedByteBuffer(targetBuffer, compressionLevel) {\n    var self = this;\n    var intermediateUncompressedByteBuffer = ByteBuffer_1.default.allocate();\n    var uncompressedLength = self.encodeIntoByteBuffer(intermediateUncompressedByteBuffer);\n    targetBuffer.putInt32(compressedEncodingCookie);\n    var pako = require(\"pako/lib/deflate\");\n    var compressionOptions = compressionLevel\n        ? { level: compressionLevel }\n        : {};\n    var compressedArray = pako.deflate(intermediateUncompressedByteBuffer.data.slice(0, uncompressedLength), compressionOptions);\n    targetBuffer.putInt32(compressedArray.byteLength);\n    targetBuffer.putArray(compressedArray);\n    return targetBuffer.position;\n}\nexports.encodeIntoCompressedByteBuffer = encodeIntoCompressedByteBuffer;\nAbstractHistogram_1.AbstractHistogram.decodeFromByteBuffer = doDecodeFromByteBuffer;\nAbstractHistogram_1.AbstractHistogram.decodeFromCompressedByteBuffer = doDecodeFromCompressedByteBuffer;\nAbstractHistogram_1.AbstractHistogram.prototype.encodeIntoByteBuffer = encodeIntoByteBuffer;\nAbstractHistogram_1.AbstractHistogram.prototype.encodeIntoCompressedByteBuffer = encodeIntoCompressedByteBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AbstractHistogram.encoding.ts\n// module id = 18\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pow = Math.pow, floor = Math.floor;\nvar TWO_POW_7 = pow(2, 7);\nvar TWO_POW_14 = pow(2, 14);\nvar TWO_POW_21 = pow(2, 21);\nvar TWO_POW_28 = pow(2, 28);\nvar TWO_POW_35 = pow(2, 35);\nvar TWO_POW_42 = pow(2, 42);\nvar TWO_POW_49 = pow(2, 49);\nvar TWO_POW_56 = pow(2, 56);\n/**\n * This class provides encoding and decoding methods for writing and reading\n * ZigZag-encoded LEB128-64b9B-variant (Little Endian Base 128) values to/from a\n * {@link ByteBuffer}. LEB128's variable length encoding provides for using a\n * smaller nuber of bytes for smaller values, and the use of ZigZag encoding\n * allows small (closer to zero) negative values to use fewer bytes. Details\n * on both LEB128 and ZigZag can be readily found elsewhere.\n *\n * The LEB128-64b9B-variant encoding used here diverges from the \"original\"\n * LEB128 as it extends to 64 bit values: In the original LEB128, a 64 bit\n * value can take up to 10 bytes in the stream, where this variant's encoding\n * of a 64 bit values will max out at 9 bytes.\n *\n * As such, this encoder/decoder should NOT be used for encoding or decoding\n * \"standard\" LEB128 formats (e.g. Google Protocol Buffers).\n */\nvar ZigZagEncoding = /** @class */ (function () {\n    function ZigZagEncoding() {\n    }\n    /**\n     * Writes a long value to the given buffer in LEB128 ZigZag encoded format\n     * (negative numbers not supported)\n     * @param buffer the buffer to write to\n     * @param value  the value to write to the buffer\n     */\n    ZigZagEncoding.encode = function (buffer, value) {\n        if (value >= 0) {\n            value = value * 2;\n        }\n        else {\n            value = -value * 2 - 1;\n        }\n        if (value < TWO_POW_7) {\n            buffer.put(value);\n        }\n        else {\n            buffer.put(value | 0x80);\n            if (value < TWO_POW_14) {\n                buffer.put(floor(value / TWO_POW_7));\n            }\n            else {\n                buffer.put(floor(value / TWO_POW_7) | 0x80);\n                if (value < TWO_POW_21) {\n                    buffer.put(floor(value / TWO_POW_14));\n                }\n                else {\n                    buffer.put(floor(value / TWO_POW_14) | 0x80);\n                    if (value < TWO_POW_28) {\n                        buffer.put(floor(value / TWO_POW_21));\n                    }\n                    else {\n                        buffer.put(floor(value / TWO_POW_21) | 0x80);\n                        if (value < TWO_POW_35) {\n                            buffer.put(floor(value / TWO_POW_28));\n                        }\n                        else {\n                            buffer.put(floor(value / TWO_POW_28) | 0x80);\n                            if (value < TWO_POW_42) {\n                                buffer.put(floor(value / TWO_POW_35));\n                            }\n                            else {\n                                buffer.put(floor(value / TWO_POW_35) | 0x80);\n                                if (value < TWO_POW_49) {\n                                    buffer.put(floor(value / TWO_POW_42));\n                                }\n                                else {\n                                    buffer.put(floor(value / TWO_POW_42) | 0x80);\n                                    if (value < TWO_POW_56) {\n                                        buffer.put(floor(value / TWO_POW_49));\n                                    }\n                                    else {\n                                        // should not happen\n                                        buffer.put(floor(value / TWO_POW_49) + 0x80);\n                                        buffer.put(floor(value / TWO_POW_56));\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Read an LEB128-64b9B ZigZag encoded long value from the given buffer\n     * (negative numbers not supported)\n     * @param buffer the buffer to read from\n     * @return the value read from the buffer\n     */\n    ZigZagEncoding.decode = function (buffer) {\n        var v = buffer.get();\n        var value = v & 0x7f;\n        if ((v & 0x80) != 0) {\n            v = buffer.get();\n            value += (v & 0x7f) * TWO_POW_7;\n            if ((v & 0x80) != 0) {\n                v = buffer.get();\n                value += (v & 0x7f) * TWO_POW_14;\n                if ((v & 0x80) != 0) {\n                    v = buffer.get();\n                    value += (v & 0x7f) * TWO_POW_21;\n                    if ((v & 0x80) != 0) {\n                        v = buffer.get();\n                        value += (v & 0x7f) * TWO_POW_28;\n                        if ((v & 0x80) != 0) {\n                            v = buffer.get();\n                            value += (v & 0x7f) * TWO_POW_35;\n                            if ((v & 0x80) != 0) {\n                                v = buffer.get();\n                                value += (v & 0x7f) * TWO_POW_42;\n                                if ((v & 0x80) != 0) {\n                                    v = buffer.get();\n                                    value += (v & 0x7f) * TWO_POW_49;\n                                    if ((v & 0x80) != 0) {\n                                        v = buffer.get();\n                                        value += (v & 0x7f) * TWO_POW_56;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (value % 2 === 0) {\n            value = value / 2;\n        }\n        else {\n            value = -(value + 1) / 2;\n        }\n        return value;\n    };\n    return ZigZagEncoding;\n}());\nexports.default = ZigZagEncoding;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ZigZagEncoding.ts\n// module id = 19\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_20__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"pako\"\n// module id = 20\n// module chunks = 0","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = ((uint8[i] << 16) & 0xFF0000) + ((uint8[i + 1] << 8) & 0xFF00) + (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/base64-js/index.js\n// module id = 21\n// module chunks = 0","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar AbstractHistogramBase_1 = require(\"./AbstractHistogramBase\");\nvar encoding_1 = require(\"./encoding\");\nvar formatters_1 = require(\"./formatters\");\nvar HISTOGRAM_LOG_FORMAT_VERSION = \"1.3\";\nvar timeFormatter = formatters_1.floatFormatter(5, 3);\nvar HistogramLogWriter = /** @class */ (function () {\n    function HistogramLogWriter(log) {\n        this.log = log;\n        /**\n         * Base time to subtract from supplied histogram start/end timestamps when\n         * logging based on histogram timestamps.\n         * Base time is expected to be in msec since the epoch, as histogram start/end times\n         * are typically stamped with absolute times in msec since the epoch.\n         */\n        this.baseTime = 0;\n    }\n    /**\n     * Output an interval histogram, with the given timestamp information and the [optional] tag\n     * associated with the histogram, using a configurable maxValueUnitRatio. (note that the\n     * specified timestamp information will be used, and the timestamp information in the actual\n     * histogram will be ignored).\n     * The max value reported with the interval line will be scaled by the given maxValueUnitRatio.\n     * @param startTimeStampSec The start timestamp to log with the interval histogram, in seconds.\n     * @param endTimeStampSec The end timestamp to log with the interval histogram, in seconds.\n     * @param histogram The interval histogram to log.\n     * @param maxValueUnitRatio The ratio by which to divide the histogram's max value when reporting on it.\n     */\n    HistogramLogWriter.prototype.outputIntervalHistogram = function (histogram, startTimeStampSec, endTimeStampSec, maxValueUnitRatio) {\n        if (startTimeStampSec === void 0) { startTimeStampSec = (histogram.startTimeStampMsec - this.baseTime) / 1000; }\n        if (endTimeStampSec === void 0) { endTimeStampSec = (histogram.endTimeStampMsec - this.baseTime) / 1000; }\n        if (maxValueUnitRatio === void 0) { maxValueUnitRatio = 1000; }\n        var base64 = encoding_1.encodeIntoBase64String(histogram);\n        var start = timeFormatter(startTimeStampSec);\n        var duration = timeFormatter(endTimeStampSec - startTimeStampSec);\n        var max = timeFormatter(histogram.maxValue / maxValueUnitRatio);\n        var lineContent = start + \",\" + duration + \",\" + max + \",\" + base64 + \"\\n\";\n        if (histogram.tag && histogram.tag !== AbstractHistogramBase_1.NO_TAG) {\n            this.log(\"Tag=\" + histogram.tag + \",\" + lineContent);\n        }\n        else {\n            this.log(lineContent);\n        }\n    };\n    /**\n     * Log a comment to the log.\n     * Comments will be preceded with with the '#' character.\n     * @param comment the comment string.\n     */\n    HistogramLogWriter.prototype.outputComment = function (comment) {\n        this.log(\"#\" + comment + \"\\n\");\n    };\n    /**\n     * Log a start time in the log.\n     * @param startTimeMsec time (in milliseconds) since the absolute start time (the epoch)\n     */\n    HistogramLogWriter.prototype.outputStartTime = function (startTimeMsec) {\n        this.outputComment(\"[StartTime: \" + formatters_1.floatFormatter(5, 3)(startTimeMsec / 1000) + \" (seconds since epoch), \" + new Date(startTimeMsec) + \"]\\n\");\n    };\n    /**\n     * Output a legend line to the log.\n     */\n    HistogramLogWriter.prototype.outputLegend = function () {\n        this.log('\"StartTimestamp\",\"Interval_Length\",\"Interval_Max\",\"Interval_Compressed_Histogram\"\\n');\n    };\n    /**\n     * Output a log format version to the log.\n     */\n    HistogramLogWriter.prototype.outputLogFormatVersion = function () {\n        this.outputComment(\"[Histogram log format version \" + HISTOGRAM_LOG_FORMAT_VERSION + \"]\");\n    };\n    return HistogramLogWriter;\n}());\nexports.default = HistogramLogWriter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/HistogramLogWriter.ts\n// module id = 22\n// module chunks = 0","\"use strict\";\n/*\n * This is a TypeScript port of the original Java version, which was written by\n * Gil Tene as described in\n * https://github.com/HdrHistogram/HdrHistogram\n * and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Int32Histogram_1 = require(\"./Int32Histogram\");\n/**\n * Records integer values, and provides stable interval {@link Histogram} samples from\n * live recorded data without interrupting or stalling active recording of values. Each interval\n * histogram provided contains all value counts accumulated since the previous interval histogram\n * was taken.\n * <p>\n * This pattern is commonly used in logging interval histogram information while recording is ongoing.\n * <p>\n * {@link Recorder} supports concurrent\n * {@link Recorder#recordValue} or\n * {@link Recorder#recordValueWithExpectedInterval} calls.\n *\n */\nvar Recorder = /** @class */ (function () {\n    /**\n     * Construct an auto-resizing {@link Recorder} with a lowest discernible value of\n     * 1 and an auto-adjusting highestTrackableValue. Can auto-resize up to track values up to Number.MAX_SAFE_INTEGER.\n     *\n     * @param numberOfSignificantValueDigits Specifies the precision to use. This is the number of significant\n     *                                       decimal digits to which the histogram will maintain value resolution\n     *                                       and separation. Must be a non-negative integer between 0 and 5.\n     * @param clock (for testing purpose) an action that give current time in ms since 1970\n     */\n    function Recorder(numberOfSignificantValueDigits, clock) {\n        if (numberOfSignificantValueDigits === void 0) { numberOfSignificantValueDigits = 3; }\n        if (clock === void 0) { clock = function () { return new Date().getTime(); }; }\n        this.numberOfSignificantValueDigits = numberOfSignificantValueDigits;\n        this.clock = clock;\n        this.activeHistogram = new Int32Histogram_1.default(1, Number.MAX_SAFE_INTEGER, numberOfSignificantValueDigits);\n        Recorder.idGenerator++;\n        this.activeHistogram.containingInstanceId = Recorder.idGenerator;\n        this.activeHistogram.startTimeStampMsec = clock();\n    }\n    /**\n     * Record a value in the histogram\n     *\n     * @param value The value to be recorded\n     * @throws may throw Error if value is exceeds highestTrackableValue\n     */\n    Recorder.prototype.recordValue = function (value) {\n        this.activeHistogram.recordValue(value);\n    };\n    /**\n     * Record a value in the histogram (adding to the value's current count)\n     *\n     * @param value The value to be recorded\n     * @param count The number of occurrences of this value to record\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    Recorder.prototype.recordValueWithCount = function (value, count) {\n        this.activeHistogram.recordValueWithCount(value, count);\n    };\n    /**\n     * Record a value\n     * <p>\n     * To compensate for the loss of sampled values when a recorded value is larger than the expected\n     * interval between value samples, Histogram will auto-generate an additional series of decreasingly-smaller\n     * (down to the expectedIntervalBetweenValueSamples) value records.\n     * <p>\n     * See related notes {@link AbstractHistogram#recordValueWithExpectedInterval(long, long)}\n     * for more explanations about coordinated omission and expected interval correction.\n     *      *\n     * @param value The value to record\n     * @param expectedIntervalBetweenValueSamples If expectedIntervalBetweenValueSamples is larger than 0, add\n     *                                           auto-generated value records as appropriate if value is larger\n     *                                           than expectedIntervalBetweenValueSamples\n     * @throws ArrayIndexOutOfBoundsException (may throw) if value is exceeds highestTrackableValue\n     */\n    Recorder.prototype.recordValueWithExpectedInterval = function (value, expectedIntervalBetweenValueSamples) {\n        this.activeHistogram.recordValueWithExpectedInterval(value, expectedIntervalBetweenValueSamples);\n    };\n    /**\n     * Get an interval histogram, which will include a stable, consistent view of all value counts\n     * accumulated since the last interval histogram was taken.\n     * <p>\n     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n     * getIntervalHistogram(histogramToRecycle)}\n     * accepts a previously returned interval histogram that can be recycled internally to avoid allocation\n     * and content copying operations, and is therefore significantly more efficient for repeated use than\n     * {@link Recorder#getIntervalHistogram()} and\n     * {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()}. The provided\n     * {@code histogramToRecycle} must\n     * be either be null or an interval histogram returned by a previous call to\n     * {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n     * getIntervalHistogram(histogramToRecycle)} or\n     * {@link Recorder#getIntervalHistogram()}.\n     * <p>\n     * NOTE: The caller is responsible for not recycling the same returned interval histogram more than once. If\n     * the same interval histogram instance is recycled more than once, behavior is undefined.\n     * <p>\n     * Calling {@link Recorder#getIntervalHistogram(Histogram histogramToRecycle)\n     * getIntervalHistogram(histogramToRecycle)} will reset the value counts, and start accumulating value\n     * counts for the next interval\n     *\n     * @param histogramToRecycle a previously returned interval histogram that may be recycled to avoid allocation and\n     *                           copy operations.\n     * @return a histogram containing the value counts accumulated since the last interval histogram was taken.\n     */\n    Recorder.prototype.getIntervalHistogram = function (histogramToRecycle) {\n        if (histogramToRecycle) {\n            var histogramToRecycleWithId = histogramToRecycle;\n            if (histogramToRecycleWithId.containingInstanceId !==\n                this.activeHistogram.containingInstanceId) {\n                throw \"replacement histogram must have been obtained via a previous getIntervalHistogram() call from this Recorder\";\n            }\n        }\n        this.inactiveHistogram = histogramToRecycle;\n        this.performIntervalSample();\n        var sampledHistogram = this.inactiveHistogram;\n        this.inactiveHistogram = null; // Once we expose the sample, we can't reuse it internally until it is recycled\n        return sampledHistogram;\n    };\n    /**\n     * Place a copy of the value counts accumulated since accumulated (since the last interval histogram\n     * was taken) into {@code targetHistogram}.\n     *\n     * Calling {@link Recorder#getIntervalHistogramInto getIntervalHistogramInto()} will reset\n     * the value counts, and start accumulating value counts for the next interval.\n     *\n     * @param targetHistogram the histogram into which the interval histogram's data should be copied\n     */\n    Recorder.prototype.getIntervalHistogramInto = function (targetHistogram) {\n        this.performIntervalSample();\n        if (this.inactiveHistogram) {\n            targetHistogram.add(this.inactiveHistogram);\n            targetHistogram.startTimeStampMsec = this.inactiveHistogram.startTimeStampMsec;\n            targetHistogram.endTimeStampMsec = this.inactiveHistogram.endTimeStampMsec;\n        }\n    };\n    /**\n     * Reset any value counts accumulated thus far.\n     */\n    Recorder.prototype.reset = function () {\n        this.activeHistogram.reset();\n        this.activeHistogram.startTimeStampMsec = this.clock();\n    };\n    Recorder.prototype.performIntervalSample = function () {\n        if (!this.inactiveHistogram) {\n            this.inactiveHistogram = new Int32Histogram_1.default(1, Number.MAX_SAFE_INTEGER, this.numberOfSignificantValueDigits);\n            this.inactiveHistogram.containingInstanceId = this.activeHistogram.containingInstanceId;\n        }\n        this.inactiveHistogram.reset();\n        var tempHistogram = this.activeHistogram;\n        this.activeHistogram = this.inactiveHistogram;\n        this.inactiveHistogram = tempHistogram;\n        var currentTimeInMs = this.clock();\n        this.inactiveHistogram.endTimeStampMsec = currentTimeInMs;\n        this.activeHistogram.startTimeStampMsec = currentTimeInMs;\n    };\n    Recorder.idGenerator = 0;\n    return Recorder;\n}());\nexports.default = Recorder;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Recorder.ts\n// module id = 23\n// module chunks = 0"],"sourceRoot":""}